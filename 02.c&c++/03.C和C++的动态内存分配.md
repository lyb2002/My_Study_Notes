# c和c++中动态内存分配的异同

## C语言中动态内存分配

参考：{[ C语言动态内存分配函数_爱上小公举的博客-CSDN博客_c语言内存分配函数](https://blog.csdn.net/qq_41071068/article/details/90741413?ops_request_misc=%7B%22request%5Fid%22%3A%22166505167816800180649813%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=166505167816800180649813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90741413-null-null.142^v51^control,201^v3^add_ask&utm_term=动态内存分配&spm=1018.2226.3001.4187)}

1. malloc()
2. free()
3. calloc()
4. realloc()

在C语言中，我们开辟内存空间的方式有两种：

### 1. 静态开辟内存

~~~c
int a;
int b[10];
~~~

静态开辟空间是**在栈中开辟的**，大小是固定的  
如果是全局数组的话，内存是在编译时分配好的，如果是局部变量数组的话，运行时在栈上静态分配内存。不管是全局数组还是局部数组，它们都有一个特点，那就是数组大小是确定的，是代码中写死的。

> 需要注意的是 ,C中const int n =10 ; n并不能作为数组长度定义数组 , 但C++中则可以

### 2. 动态开辟内存 

在C中动态开辟空间需要用到三个函数 :
`malloc()`, `calloc()`, `realloc() `,这三个函数都是向堆中申请的内存空间.
 在堆中申请的内存空间不会像在栈中存储的局部变量一样 ,函数调用完会自动释放内存 , 需要我们手动释放 ,就需要`free()`函数来完成.   

2.1 malloc()

void * malloc（size_t size）

- 向**堆**中申请一片连续的可用内存空间
- 若申请成功 ,返回指向这片内存空间的指针 ,若失败 ,则会返回NULL, 所以我们在用malloc()函数开辟[动态内存](https://so.csdn.net/so/search?q=动态内存&spm=1001.2101.3001.7020)之后, 一定要判断函数返回值是否为NULL.
- 返回值的类型为void型, malloc()函数并不知道连续开辟的size个字节是存储什么类型数据的 ,所以需要我们自行决定 ,方法是在malloc()前加强制转 ,转化成我们所需类型 ,如: `(int)malloc(sizeof(int)*n)`.
- 如果size为0, 此行为是未定义的, 会发生未知错误, 取决于编译器


2.2 free()

void free(void* ptr)

在堆中申请的内存空间不会像在栈中存储的局部变量一样 ,函数调用完会自动释放内存 , 如果我们不手动释放, 直到程序运行结束才会释放, 这样就可能会造成内存泄漏, 即堆中这片内存中的数据已经不再使用, 但它一直占着这片空间, (通俗说就是就是占着茅坑不拉屎), 所以当我们申请的动态内存不再使用时 ,一定要及时释放 .

- 如果ptr没有指向使用动态内存分配函数分配的内存空间，则会导致未定义的行为。
- 如果ptr是空指针，则该函数不执行任何操作。
- 此函数不会更改ptr本身的值，因此它仍指向相同（现在已经无效）的位置(内存)
- 在free()函数之后需要将ptr再置空 ,即ptr = NULL;如果不将ptr置空的话 ,后面程序如果再通过ptr会访问到已经释放过无效的或者已经被回收再利用的内存, 为保证程序的健壮性, 一般我们都要写ptr = NULL;

>  free()不能重复释放一块内存

2.3 calloc()

void * calloc（size_t num，size_t size）

与malloc()函数的区别只在于, calloc()函数会在返回地址之前将所申请的内存空间中的每个字节都**初始化为0** .

2.4 realloc()

void * realloc（void * ptr，size_t size）

可以做到对动态开辟内存大小的调整(既可以往大调整, 也可以往小了调整) .

- ptr为需要调整的内存地址
- size为调整后需要的大小(字节数)
- 若调整成功, 返回值为调整大小后内存的起始位置(也就是指向调整后内存的指针), 若失败(当没有内存可以分配时, 一般不会出现), 则返回NULL, 所以还是要对返回值判空
- 如果ptr是空指针, 则和malloc()函数一样作用一样

>注意 : realloc()函数在扩大内存空间时有两种情况:
>
>ptr所指的内存后有足够的内存空间用来扩展，直接增加
>
>ptr所指内存后没有足够的空间来扩展，寻找新空间并拷贝原内容

## C++中动态内存分配

参考：[【C++】动态内存分配详解（new/new[\]和delete/delete[]）_GeekBuilding的博客-CSDN博客_c++动态分配内存](https://blog.csdn.net/qq_40416052/article/details/82493916?ops_request_misc=%7B%22request%5Fid%22%3A%22166505169016800182736110%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=166505169016800182736110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82493916-null-null.142^v51^control,201^v3^add_ask&utm_term=c%2B%2B动态内存分配&spm=1018.2226.3001.4187)

new/new[]和delete/delete[]

1. 变量申请

```c++
Type* pointer = new Type;
//...
delete pointer;
```

2. 数组申请

```c++
Type* pointer = new Type[N];
//...
delete[] pointer;
```

### 1.new关键字的初始化

在申请单个变量时可以初始化

```c++
int* pi = new int(1);
float* pf = new float(2.0f);
char* pc = new char('c');
```

> 注意：
>
> | int* pi = new int(1); | 表示动态分配一个int ，初始化为 1  |
> | --------------------- | :-------------------------------- |
> | int* pa = new int[1]; | 表示动态分配一个数组，数组大小为1 |
>		

### 2. C++动态分配内存异常机制

事项一下，我们的计算机内存优先，如果我们分配一个很大的内存空间，会出现栈满，程序产生异常，程序崩溃。所以我们需要引入异常机制。

C ++提供了两种标准机制来检查分配是否成功。

**（1）一个是处理异常。**

使用此方法，在分配失败时抛出**bad_alloc**类型的异常。 例外是这些教程后面解释的强大的C ++特性。 但是现在，您应该知道如果抛出此异常并且未由特定处理程序处理，则程序执行将终止。

此异常方法是new默认使用的方法，并且是在声明中使用的方法，like:

```c++
   foo = new int [5];  // if allocation fails, an exception is thrown
```

**（2）另一种方法称为nothrow**

  当使用它时会发生的情况是，当内存分配失败时，而不是抛出bad_alloc异常或终止程序，**new返回的指针是空指针，程序继续正常执行 。**

  可以使用名为nothrow的特殊对象（在header <new>中声明）作为new的参数来指定此方法：

```c++
foo = new (nothrow) int [5];
```

## C与C++的异同

| new关键字是C++的一部分                  | malloc是由C库提供的函数            |
| --------------------------------------- | ---------------------------------- |
| **new以具体类型为单位进行内存分配**     | **malloc以字节为单位进行内存分配** |
| **new在申请单个类型变量时可进行初始化** | **malloc不具备内存初始化的特性**   |

