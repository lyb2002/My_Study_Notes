# SpringBootWeb综合案例

![image-20231213235644833](assets/image-20231213235644833.png)



# 1、准备工作

## 环境搭建

- 准备数据库表(dept、emp)

- 创建springboot工程，引入对应的起步依赖（web、mybatis、mysql驱动、lombok）

- 配置文件application.properties中引入mybatis的配置信息，准备对应的实体类

- 准备对应的Mapper、Service(接口、实现类)、Controller基础结构

![image-20231214000058114](assets/image-20231214000058114.png)



1、创建数据库 tlias，在第10天资料中，复制表信息的sql语句

2、创建springboot工程

![image-20231214000720175](assets/image-20231214000720175.png)

![image-20231214000838666](assets/image-20231214000838666.png)

![image-20231214000851790](assets/image-20231214000851790.png)

![image-20231214000906740](assets/image-20231214000906740.png)

3、配置application.properties文件

```properties
#驱动包
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#数据库url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
#用户名
spring.datasource.username=root
#密码
spring.datasource.password=123456

#指定mybatis输出日志的位置,输出控制台
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

#开启Mybatis的驼峰命名自动映射开关
mybatis.configuration.map-underscore-to-camel-case=true
```

4、准备对应的实体类、Mapper、Service(接口、实现类)、Controller基础结构

![image-20231214003122955](assets/image-20231214003122955.png)



# 2、开发规范

案例基于当前最为主流的前后端分离模式进行开发。

![image-20231214003638702](assets/image-20231214003638702.png)



开发规范 - Restful

REST（REpresentational State Transfer），表述性状态转换，它是一种软件架构风格

![image-20231214003724969](assets/image-20231214003724969.png)

![image-20231214004013983](assets/image-20231214004013983.png)

![image-20231214004043904](assets/image-20231214004043904.png)



开发规范 - 统一响应结果

前后端交互统一响应结果 Result

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Integer code;//响应码，1 代表成功; 0 代表失败
    private String msg;  //响应信息 描述字符串
    private Object data; //返回的数据
    public static Result success(){ //增删改 成功响应
        return new Result(1,"success",null);
    }
    public static Result success(Object data){ //查询 成功响应
        return new Result(1,"success",data);
    }
    public static Result error(String msg){ //失败响应
        return new Result(0,msg,null);
    }
}
```



开发流程

![image-20231214004359295](assets/image-20231214004359295.png)



# 3、部门管理

## 查询部门

![image-20231214004656780](assets/image-20231214004656780.png)

DeptController.java

```java
/**
 * 部门管理Controller
 */
@Slf4j
@RestController
public class DeptController {
    //加上注解@Slf4j后，不需要在写以下代码，由lombok提供
    //private static Logger log = LoggerFactory.getLogger(DeptController.class);

    @Autowired
    private DeptService deptService;

    //限定请求方式为GET，不指定则所有方式请求都可以通过
    //@RequestMapping(value = "/depts", method = RequestMethod.GET)
    //衍生注解，方便记忆
    @GetMapping("/depts")
    public Result list(){
        log.info("查询全部部门数据");

        //调用service查询部门数据
        List<Dept> deptList = deptService.list();

        return Result.success(deptList);
    }
}
```

DeptService.java

```java
/**
 * 部门管理Service
 */
public interface DeptService {
    /**
     * 查询全部部门数据
     * @return
     */
    List<Dept> list();
}
```

DeptServiceImpl.java

```java
@Service
public class DeptServiceImpl implements DeptService {

    @Autowired
    private DeptMapper deptMapper;

    @Override
    public List<Dept> list() {
        return deptMapper.list();
    }
}
```

DeptMapper.java

```java
@Mapper
public interface DeptMapper {
    /**
     * 查询全部部门
     * @return
     */
    @Select("select * from dept")
    public List<Dept> list();
}
```

postman测试：

![image-20231214011528653](assets/image-20231214011528653.png)



## 前后端联调

- 将资料中提供的“前端工程” 文件夹中的压缩包，拷贝到一个没有中文不带空格的目录下，解压。

- 启动nginx，访问测试：[http://localhost:90](http://localhost:90/)

![image-20231217153833026](assets/image-20231217153833026.png)



## 删除部门

![image-20231217154049324](assets/image-20231217154049324.png)

需要使用两个注解：`@DeleteMapping`、`@PathVariable`

DeptController.java

```java
/**
     * 删除部门
     * @return
     */
@DeleteMapping("/depts/{id}")
public Result delete(@PathVariable Integer id){
    log.info("根据id删除部门：{}", id);
    deptService.delete(id);

    return Result.success();
}
```

DeptService.java

```java
/**
     * 删除部门
     * @param id
     */
void delete(Integer id);
```

DeptServiceImpl.java

```java
@Override
public void delete(Integer id) {
    deptMapper.deleteById(id);
}
```

DeptMapper.java

```java
@Delete("delete from dept where id = #{id}")
void deleteById(Integer id);
```



## 新增部门

![image-20231217160147670](assets/image-20231217160147670.png)

请求路径：/depts 

请求方式：POST 

接口描述：该接口用于添加部门数据

请求参数样例：

```json
{
"name": "教研部"
}
```



DeptController.java

```java
/**
     * 新增部门
     * @return
     */
@PostMapping("/depts")
public Result add(@RequestBody Dept dept){
    log.info("新增部门：{}", dept);
    //调用service新增部门
    deptService.add(dept);
    return Result.success();
}
```

DeptService.java

```java
/**
     * 新增部门
     * @param dept
     */
void add(Dept dept);
```

DeptServiceImpl.java

```java
@Override
public void add(Dept dept) {
    dept.setCreateTime(LocalDateTime.now());
    dept.setUpdateTime(LocalDateTime.now());

    deptMapper.insert(dept);
}
```

DeptMapper.java

```java
/**
     * 新增部门
     * @param dept
     */
@Insert("insert into dept(name, create_time, update_time) value (#{name},#{createTime},#{updateTime})")
void insert(Dept dept);
```



## 简化-抽取公共路径

![image-20231217161453188](assets/image-20231217161453188.png)

注意事项：

**一个完整的请求路径，应该是类上的 @RequestMapping 的value属性 + 方法上的 @RequestMapping的value属性。**





# 4、员工管理

## 4.1 分页查询

![image-20231217164914542](assets/image-20231217164914542.png)

需要定义一个实体类，封装返回的数据

![image-20231217165256219](assets/image-20231217165256219.png)

![image-20231217165434596](assets/image-20231217165434596.png)

EmpController.java

```java
/**
 * 员工管理Controller
 */
@Slf4j
@RestController
public class EmpController {

    @Autowired
    private EmpService empService;

    @GetMapping("/emps")
    public Result page(@RequestParam(defaultValue = "1") Integer page,
                       @RequestParam(defaultValue = "10") Integer pageSize){
        log.info("分页查询，参数：{}，{}", page, pageSize);
        //调用Service分页查询
        PageBean pageBean = empService.page(page,pageSize);
        return Result.success(pageBean);
    }

}
```

EmpService.java

```java
/**
 * 员工管理Service
 */
public interface EmpService {
    /**
     * 分页查询
     * @param page
     * @param pageSize
     * @return
     */
    PageBean page(Integer page, Integer pageSize);
}
```

EmpServiceImpl.java

```java
@Service
public class EmpServiceImpl implements EmpService {

    @Autowired
    private EmpMapper empMapper;

    @Override
    public PageBean page(Integer page, Integer pageSize) {
        //1. 获取总记录数
        Long count = empMapper.count();

        //2. 获取分页查询结果列表
        Integer start = (page - 1) * pageSize;
        List<Emp> empList = empMapper.page(start,pageSize);

        //3. 封装PageBean对象
        PageBean pageBean = new PageBean(count, empList);

        return pageBean;
    }
}
```

EmpMapper.java

```java
@Mapper
public interface EmpMapper {

    /**
     * 查询总记录数
     * @return
     */
    @Select("select count(*) from emp")
    public Long count();

    /**
     * 分页查询，获取列表数据
     * @param start
     * @param pageSize
     * @return
     */
    @Select("select * from emp limit #{start}, #{pageSize}")
    public List<Emp> page(Integer start, Integer pageSize);
}
```



总结：注解

```java
@RequestParam(defaultValue="1") //设置请求参数默认值
```



## 4.2 分页插件PageHelper

![image-20231217171929826](assets/image-20231217171929826.png)

使用步骤：

**1、在 pom.xml 文件中，引入pagehelper的依赖**

```xml
<!--PageHelper插件-->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.6</version>
</dependency>
```

**2、在 EmpMapper 中，编写查询语句查询到所有员工**

```java
//员工信息查询
@Select("select * from emp")
public List<Emp> list();
```

分页插件会自动的获取到我们的查询语句

然后将select后的查询字段列表换成聚合函数 `count(*)`

然后自动的执行这条sql语句，获取**总记录数**

然后再对这条sql语句进行改造，再其后加上 `limit` 查询，获取**列表数据**

**3、在 EmpServiceImpl 中，使用分页插件功能**

```java
@Override
public PageBean page(Integer page, Integer pageSize) {
    //1. 设置分页参数
    PageHelper.startPage(page,pageSize);

    //2. 执行查询
    List<Emp> empList = empMapper.list();
    Page<Emp> p = (Page<Emp>) empList;

    //3. 封装PageBean对象
    PageBean pageBean = new PageBean(p.getTotal(), p.getResult());

    return pageBean;
}
```



## 4.3 条件分页查询

![image-20231219152658556](assets/image-20231219152658556.png)

步骤：

1、修改 `EmpController` ，加上缺少的参数信息

![image-20231219154300207](assets/image-20231219154300207.png)

2、修改 `EmpServiceImpl` ，加上缺少的参数信息

![image-20231219154344070](assets/image-20231219154344070.png)

3、修改 `EmpMapper` 接收的参数，并配置 `EmpMapper.xml` 实现动态SQL

![image-20231219154502294](assets/image-20231219154502294.png)

测试：

![image-20231219155256297](assets/image-20231219155256297.png)



## 4.4 删除员工

包括删除单个员工和批量删除员工，只需要开发一个接口即可，单个员工可以看成一种特殊形式

![image-20231219155521921](assets/image-20231219155521921.png)



## 4.5 新增员工

<img src="assets/image-20231219160951643.png" alt="image-20231219160951643" style="zoom: 67%;" />

![image-20231219161032575](assets/image-20231219161032575.png)

实现：

![image-20231219163625855](assets/image-20231219163625855.png)

测试：

![image-20231219163647851](assets/image-20231219163647851.png)



## 4.6 文件上传

### 简介

- 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。

- 文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。

**前端页面三要素：**

1. 必须要有一个form表单，其中有一个表单项file
2. 表单的提交方式必须是 post 方式
3. ==设置表单传输的编码格式为 `enctype="multipart/form-data"`==

![image-20231219163913163](assets/image-20231219163913163.png)

![image-20231219193107400](assets/image-20231219193107400.png)

使用默认的提交方式，image 中只包含文件名。

![image-20231219193533778](assets/image-20231219193533778.png)

将 enctype 设置为 `multipart/form-data` ，此时表单在提交时是分为多个部分去提交的。

每一个表单项就是要给单独的部分，多个部分之间使用后面自动生成的分隔符分开。

![image-20231219193753280](assets/image-20231219193753280.png)

![image-20231219194057068](assets/image-20231219194057068.png)

![image-20231219194043451](assets/image-20231219194043451.png)



**服务端接收文件：**

创建一个新的 Controller 类，使用 MultipartFile 接收文件

```java
@Slf4j
@RestController
public class UploadController {
    @PostMapping("/upload")  
    public Result upload(String username , Integer age , 
                         @RequestParam("image") MultipartFile file){
        log.info("文件上传：{}，{}，{}", username, age, image);
        return Result.success();
    }
}
```

设置断点，以调试的方式启动

<img src="assets/image-20231219195414196.png" alt="image-20231219195414196" style="zoom:80%;" />

拷贝路径，在资源管理器中打开

可以看到三个临时文件

![image-20231219195534050](assets/image-20231219195534050.png)

分别保存了 username，age，image 中的值。

将断点放开，可以看到这三个临时文件消失了。



小结：

1.前端页面三要素

- 表单项 type=“file”

- 表单提交方式 post

- 表单的enctype属性 multipart/form-data

2.服务端接收文件

- MultipartFile



### 本地存储

在服务端，接收到上传上来的文件之后，将文件存储在本地服务器磁盘中。

```java
@Slf4j
@RestController
public class UploadController {

    @PostMapping("/upload")
    public Result upload(String username, Integer age, MultipartFile image) throws IOException {
        log.info("文件上传：{}，{}，{}", username, age, image);

        //获取原始文件名
        String originalFilename = image.getOriginalFilename();
        //将文件存储在服务器所在的磁盘目录中 D:\images
        image.transferTo(new File("D:\\images\\"+originalFilename));

        return Result.success();
    }

}
```

以上代码可以将图片保存在服务器的 `D:\\images` 目录下，当该目录不存在时，会抛出异常。

此时，有一个问题，上述代码保存时使用的是文件的原始名称，当文件重名时，会覆盖原来的文件。

使用 UUID + 文件拓展名 构建生成的文件名

```java
@Slf4j
@RestController
public class UploadController {

    @PostMapping("/upload")
    public Result upload(String username, Integer age, MultipartFile image) throws IOException {
        log.info("文件上传：{}，{}，{}", username, age, image);

        //获取原始文件名
        String originalFilename = image.getOriginalFilename();

        //构建唯一的文件名（不能重复） -- uuid（通用唯一识别码）32位，算上'-' 36位
        int index = originalFilename.lastIndexOf(".");
        String extname = originalFilename.substring(index);
        String newFileName = UUID.randomUUID().toString() + extname;
        log.info("新的文件名：{}", newFileName);

        //将文件存储在服务器所在的磁盘目录中 D:\images
        image.transferTo(new File("D:\\images\\"+newFileName));

        return Result.success();
    }

}
```

当上传的文件大小大于 1M 时，会报如下错误：

![image-20231219201558116](assets/image-20231219201558116.png)

在SpringBoot中，文件上传，默认单个文件允许最大大小为 1M。如果需要上传大文件，可以进行如下配置：

```properties
#配置单个文件最大上传大小
spring.servlet.multipart.max-file-size=10MB
#配置单个请求最大上传大小(一次请求可以上传多个文件)
spring.servlet.multipart.max-request-size=100MB
```



本地存储的缺点：

- 文件没法在浏览器中直接访问。
- 存储在本地服务器中，不方便扩容。
- 磁盘坏了，所有文件丢失。

![image-20231219202409223](assets/image-20231219202409223.png)

自己搭建：FastDFS、MinIO



### 阿里云OSS

阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的云服务提供商 。

阿里云对象存储OSS（Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。

![image-20231219202711679](assets/image-20231219202711679.png)

使用第三方服务-通用思路

![image-20231219202749117](assets/image-20231219202749117.png)

**SDK**：Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等，都可以叫做SDK。

阿里云OSS-使用步骤

![image-20231219202812347](assets/image-20231219202812347.png)

**Bucket**：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间。

获取AccessKey密钥：右上角

```
AccessKey ID
LTAI5t6eLJRQxUs2p12TFj75

AccessKey Secret
I5T4oc64vr5qRAAg0hA0d9QXwPW9PT
```



参照官方的SDK示例编写入门程序

在Maven项目中加入依赖项

```xml
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
    <version>3.15.1</version>
</dependency>
```

如果使用的是Java 9及以上的版本，则需要添加JAXB相关依赖。添加JAXB相关依赖示例代码如下：

```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
    <groupId>javax.activation</groupId>
    <artifactId>activation</artifactId>
    <version>1.1.1</version>
</dependency>
<!-- no more than 2.3.3-->
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>2.3.3</version>
</dependency>
```

编写示例代码和测试

```java
package com.lyb;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.common.auth.*;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import com.aliyun.oss.model.PutObjectRequest;
import com.aliyun.oss.model.PutObjectResult;
import java.io.FileInputStream;
import java.io.InputStream;

public class Demo {

    public static void main(String[] args) throws Exception {
        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
        String endpoint = "https://oss-cn-guangzhou.aliyuncs.com";
        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
        // 填写Bucket名称，例如examplebucket。
        String bucketName = "web-tlias-lyb";
        // 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。
        String objectName = "1.jpg";
        // 填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。
        // 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。
        String filePath= "D:\\images\\win.png";

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, credentialsProvider);

        try {
            InputStream inputStream = new FileInputStream(filePath);
            // 创建PutObjectRequest对象。
            PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectName, inputStream);
            // 创建PutObject请求。
            PutObjectResult result = ossClient.putObject(putObjectRequest);
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
    }
} 
```



集成 OSS 服务

![image-20231219205707630](assets/image-20231219205707630.png)

![image-20231219205846397](assets/image-20231219205846397.png)

```java
@Slf4j
@RestController
public class UploadController {
    @Autowired
    private AliOSSUtils aliOSSUtils;

    @PostMapping("/upload")
    public Result upload(MultipartFile image) throws IOException {
        log.info("文件上传，文件名：{}", image.getOriginalFilename());

        String url = aliOSSUtils.upload(image);
        log.info("文件上传完成，文件访问的url：{}", url);

        return Result.success(url);
    }
}
```

使用 @Value 注解获取配置文件中的信息

```java
package com.lyb.utils;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.common.auth.CredentialsProviderFactory;
import com.aliyun.oss.common.auth.EnvironmentVariableCredentialsProvider;
import com.aliyuncs.exceptions.ClientException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;
import java.io.*;
import java.util.UUID;

/**
 * 阿里云 OSS 工具类
 */
@Component
public class AliOSSUtils {

    @Value("${aliyun.oss.endpoint}") //https://oss-cn-guangzhou.aliyuncs.com
    private String endpoint;
//    //private EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();
    @Value("${aliyun.oss.accessKeyId}")//LTAI5t6eLJRQxUs2p12TFj75
    private String accessKeyId;
    @Value("${aliyun.oss.accessKeySecret}")//I5T4oc64vr5qRAAg0hA0d9QXwPW9PT
    private String accessKeySecret;
    @Value("${aliyun.oss.bucketName}")//web-tlias-lyb
    private String bucketName;

    @Autowired
    private AliOSSProperties aliOSSProperties;

    public AliOSSUtils() throws ClientException {
    }

    /**
     * 实现上传图片到OSS
     */
    public String upload(MultipartFile file) throws IOException {
        // 获取上传的文件的输入流
        InputStream inputStream = file.getInputStream();

        // 避免文件覆盖
        String originalFilename = file.getOriginalFilename();
        String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf("."));

        //上传文件到 OSS
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        ossClient.putObject(bucketName, fileName, inputStream);

        //文件访问路径
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + fileName;
        // 关闭ossClient
        ossClient.shutdown();
        return url;// 把上传到oss的路径返回
    }

}
```





## 4.7 修改员工

### 查询回写

![image-20231219213507206](assets/image-20231219213507206.png)

<img src="assets/image-20231219214123444.png" alt="image-20231219214123444" style="zoom:80%;" />



### 修改员工

![image-20231219214145346](assets/image-20231219214145346.png)



# 5、配置文件

## 参数配置化

![image-20231219224340209](assets/image-20231219224340209.png)

## yml配置文件

SpringBoot提供了多种属性配置方式

- application.properties

```properties
server.port=8080
server.address=127.0.0.1
```

- application.yml

```yaml
server:
   port:  8080
   address: 127.0.0.1
```

- application.yaml

```yaml
server:
   port:  8080
   address: 127.0.0.1
```



![image-20231219224752876](assets/image-20231219224752876.png)

**yml**

基本语法

- 大小写敏感

- ==数值前边必须有空格，作为分隔符==

- 使用缩进表示层级关系，缩进时，**不允许使用Tab键**，只能用空格（idea中会自动将Tab转换为空格）

- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

- \# 表示注释，从这个字符一直到行尾，都会被解析器忽略



yml数据格式

- 对象/Map集合：

```yml
user:
   name: zhangsan
   age: 18
   password: 123456
```

- 数组/List/Set集合：

```yml
hobby:
   - java
   - game
   - sport
```



在application.yml中的配置案例相关的配置项

<img src="assets/image-20231219225935148.png" alt="image-20231219225935148" style="zoom: 67%;" />



## @ConfigurationProperties

问题分析：

![image-20231219230121963](assets/image-20231219230121963.png)

使用 `@ConfigurationProperties` 注解

定义一个类，属性名与配置文件中的名称相对应。

@Data 注解生成get和set方法

@Component 注解将其交给IOC容器管理

@ConfigurationProperties 中 prefix 属性配置前缀

![image-20231219230336540](assets/image-20231219230336540.png)

在工具类中，使用 @Autowired 注解将自动生成该类的实例对象。

报错解决：

![image-20231219231917992](assets/image-20231219231917992.png)

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
</dependency>
```

**@ConfigurationProperties 与 @Value**

![image-20231219232040355](assets/image-20231219232040355.png)

![image-20231219232043110](assets/image-20231219232043110.png)





# 6、登录

## 6.1 基础登录功能

思路：

![image-20231219232341210](assets/image-20231219232341210.png)

![image-20231219233633550](assets/image-20231219233633550.png)

测试：

![image-20231219233658528](assets/image-20231219233658528.png)



## 6.2 登录校验

问题：在未登录情况下，我们也可以直接访问部门管理、员工管理等功能。

![image-20231219234023326](assets/image-20231219234023326.png)

http 是无状态的协议，两次请求之间是独立的，因此无法判断一个用户是否登录了。

![image-20231220001346667](assets/image-20231220001346667.png)

通过统一拦截技术，拦截浏览器发来的请求，并对请求进行校验，校验员工是否登录。



### 会话技术

**会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含==多次==请求和响应。**

**会话跟踪：**一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间==共享数据==。

会话跟踪方案：

- 客户端会话跟踪技术：==Cookie==

- 服务端会话跟踪技术：==Session==

- **令牌技术**

![image-20231220002044894](assets/image-20231220002044894.png)

### 会话跟踪方案

**方案一：Cookie**

![image-20231220002606484](assets/image-20231220002606484.png)

![image-20231220002714163](assets/image-20231220002714163.png)

设置方式：设置一个响应头：`Set-Cookie`，浏览器会自动解析响应头，拿到响应头对应的数据部分，将Cookie的值存储在浏览器本地，后续的每一次请求中，都会将浏览器存储的Cookie值直接在请求头当中，通过 `Cookie` 这个请求头携带到服务端当中。

![image-20231220003649942](assets/image-20231220003649942.png)

==Cookie不能跨域！==

![image-20231220003827255](assets/image-20231220003827255.png)

**前端程序和服务端程序分别部署在不同的服务器中。**

跨域区分三个维度：协议、IP/域名、端口

任何一个不同都称为跨域操作。



**方案二：Session**

![image-20231220010239377](assets/image-20231220010239377.png)

![image-20231220010243262](assets/image-20231220010243262.png)

浏览器第一次请求服务器时，在服务器当中获取Session，由服务器自动创建，每一个Session对象都有一个id，服务端响应数据的时候，会将Session的id通过Cookie响应给浏览器。

本质：在响应头当中，增加了 `Set-Cookie` 这个响应头，底层就是基于 Cookie 的

![image-20231220011349004](assets/image-20231220011349004.png)

问题：

一般开发的项目，不会只部署在一台服务器上，因为单台服务器存在一个很大的问题，就是==单点故障==。

![image-20231220011614296](assets/image-20231220011614296.png)

缺点：

- 服务器集群环境下无法直接使用Session

- Cookie的缺点



**方案三：令牌技术**

![image-20231220013503115](assets/image-20231220013503115.png)

![image-20231220013509293](assets/image-20231220013509293.png)



### JWT令牌

简介：

- 全称：JSON Web Token （https://jwt.io/）

- 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。

将json数据格式进行了安全封装。

![image-20231220013915465](assets/image-20231220013915465.png)

组成：

- 第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{"alg":"HS256","type":"JWT"}

- 第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{"id":"1","username":"Tom"}

- 第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。

应用场景：

- 登录认证。
    - 登录成功后，**生成令牌**
    - 后续每个请求，都要携带JWT令牌，系统在每次请求处理之前，先**校验令牌**，通过后，再处理



**JWT-生成和校验**

1、引入JWT的依赖

pom.xml

```xml
<!--JWT令牌-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

2、在单元测试类中，编写测试代码

```java
/**
	 * 生成JWT
	 */
@Test
public void testGenJwt(){
    Map<String, Object> claims = new HashMap<>();
    claims.put("id",1);
    claims.put("name","Tom");

    String jwt = Jwts.builder()
        .signWith(SignatureAlgorithm.HS256, "itheima")//设置签名算法
        .setClaims(claims)//自定义内容（载荷）
        .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000))//设置有效期位1小时
        .compact();
    System.out.println(jwt);
}

/**
	 * 解析JWT
	 */
@Test
public void testParseJwt(){
    Claims claims = Jwts.parser()
        .setSigningKey("itheima")
        .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiVG9tIiwiaWQiOjEsImV4cCI6MTcwMzAxMjI5MH0.J5yk_vDU2fP6qSFPZOt3eUGkT6j7UwmZgCep0K0T70U")
        .getBody();
    System.out.println(claims);
}
```

<img src="assets/image-20231220020318857.png" alt="image-20231220020318857" style="zoom: 50%;" />



**JWT-登录后下发令牌**

思路：

- 令牌生成：登录成功后，生成JWT令牌，并返回给前端。

- 令牌校验：在请求到达服务端后，对令牌进行统一拦截、校验

>用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要 在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的 JWT令牌。 如果检测到用户未登录，则会返回如下固定错误信息：
>
>```json
>{
>    "code": 0,
>    "msg": "NOT_LOGIN",
>    "data": null
>}
>```

步骤：

- 引入JWT令牌操作工具类。

- 登录完成后，调用工具类生成JWT令牌，并返回。

```java
package com.lyb.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.util.Date;
import java.util.Map;

public class JwtUtils {

    private static String signKey = "itheima";
    private static Long expire = 43200000L; //过期时间为12小时

    /**
     * 生成JWT令牌
     * @param claims JWT第二部分负载 payload 中存储的内容
     * @return
     */
    public static String generateJwt(Map<String, Object> claims){
        String jwt = Jwts.builder()
                .addClaims(claims)
                .signWith(SignatureAlgorithm.HS256, signKey)
                .setExpiration(new Date(System.currentTimeMillis() + expire))
                .compact();
        return jwt;
    }

    /**
     * 解析JWT令牌
     * @param jwt JWT令牌
     * @return JWT第二部分负载 payload 中存储的内容
     */
    public static Claims parseJWT(String jwt){
        Claims claims = Jwts.parser()
                .setSigningKey(signKey)
                .parseClaimsJws(jwt)
                .getBody();
        return claims;
    }
}
```

```java
@Slf4j
@RestController
public class LoginController {

    @Autowired
    private EmpService empService;

    @PostMapping("/login")
    public Result login(@RequestBody Emp emp){
        log.info("员工登录：{}", emp);
        Emp e = empService.login(emp);

        //登录成功，生成令牌，下发令牌
        if(e != null){
            Map<String, Object> claims = new HashMap<>();
            claims.put("id", e.getId());
            claims.put("name", e.getName());
            claims.put("username", e.getUsername());

            String jwt = JwtUtils.generateJwt(claims);//jwt包含了当前登录的员工信息
            return Result.success(jwt);
        }

        //登录失败，返回错误信息
        return Result.error("用户名或密码登录");
    }
}
```

测试：

![image-20231220021745157](assets/image-20231220021745157.png)

本地存储在移动端也存在。

![image-20231220021955395](assets/image-20231220021955395.png)



![image-20231220022127645](assets/image-20231220022127645.png)



## 6.3 过滤器Filter

概述：

- 概念：**Filter 过滤器**，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。

- 过滤器可以把对资源的请求**拦截**下来，从而实现一些特殊的功能。

- 过滤器一般完成一些**通用**的操作，比如：登录校验、统一编码处理、敏感字符处理等。

![image-20231220151609838](assets/image-20231220151609838.png)

将请求拦截下来，想要访问后面的资源，必须先通过 Filter。

### 快速入门

步骤：

1. 定义Filter：定义一个类，实现 Filter 接口，并重写其所有方法。

2. 配置Filter：Filter类上加 `@WebFilter` 注解，配置拦截资源的路径。引导类上加 `@ServletComponentScan` 开启Servlet组件支持。

com.lyb.filter.DemoFilter.java

```java
package com.lyb.filter;

import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;

import java.io.IOException;

@WebFilter(urlPatterns = "/*")
public class DemoFilter implements Filter {
    @Override   //初始化方法，Web服务器启动，创建Filter时调用，只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("init 初始化方法执行了");
    }

    @Override   //拦截到请求时，调用该方法，可调用多次
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了请求");
    }

    @Override   //销毁方法，服务器关闭时调用，只调用一次
    public void destroy() {
        System.out.println("destroy 销毁方法执行了");
    }
}
```

Filter 是javaWeb的三大组件之一，并不是springboot中提供的。

在springboot项目当中，要想使用Filter功能，必须在启动类上加注解 `@ServletComponentScan`

启动类：

```java
@ServletComponentScan	//开启对Servlet组件的支持
@SpringBootApplication
public class TliasWebManagementApplication {

	public static void main(String[] args) {
		SpringApplication.run(TliasWebManagementApplication.class, args);
	}

}
```

==注意：Filter 为servlet包下的==

![image-20231220152258326](assets/image-20231220152258326.png)



此时，重新启动服务，可以看到，init方法执行了，而且只在启动时执行一次。

此时，刷新前端页面，会发现数据没有加载出来，在后端控制台会输出拦截到了请求，每刷新一次输出一次

<img src="assets/image-20231220155813113.png" alt="image-20231220155813113" style="zoom:80%;" />

这是因为Filter拦截到了请求，但是没有放行。

放行：

```java
@Override   //拦截到请求时，调用该方法，可调用多次
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    System.out.println("拦截到了请求");
    //放行
    filterChain.doFilter(servletRequest,servletResponse);
}
```



小结：

1. 实现Filter接口（Servlet实现）
2. 两个注解：`@WebFilter(urlPatterns="/*")`、`@ServletComponentScan`



### 详解（执行流程、拦截路径、过滤器链）

**执行流程：**

- 先执行放行前的逻辑，在放行到具体的业务逻辑，执行完后再执行放行后的逻辑

放行操作：`chain.doFilter(request, response);`

```java
@Override   //拦截到请求时，调用该方法，可调用多次
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    System.out.println("拦截到了请求");
    System.out.println("执行放行前逻辑...");
    
    //放行
    filterChain.doFilter(servletRequest,servletResponse);
    
    System.out.println("执行放行后逻辑...");
}
```

疑问：

1. 放行后访问对应资源，资源访问完成后，还会回到Filter中吗？

    会

2. 如果回到Filter中，是重新执行还是执行放行后的逻辑呢？

    执行放行后逻辑



**Filter拦截路径：**

- Filter 可以根据需求，配置不同的拦截资源路径：

| 拦截路径     | urlPatterns值 | 含义                               |
| ------------ | ------------- | ---------------------------------- |
| 拦截具体路径 | /login        | 只有访问 /login 路径时，才会被拦截 |
| 目录拦截     | /emps/*       | 访问/emps下的所有资源，都会被拦截  |
| 拦截所有     | /*            | 访问所有资源，都会被拦截           |



**过滤器链**

- 介绍：**一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个==过滤器链==。**

![image-20231220165029131](assets/image-20231220165029131.png)

FilterChain 就是过滤器链，当我们在一个过滤器中执行 `fliterChain.doFilter()` 方法放行时，会进入到下一个过滤器中，当当前是最后一个过滤器时，会放行到对应的Web资源。

![image-20231220165553309](assets/image-20231220165553309.png)

定义了两个过滤器：AbcFilter、DemoFilter

执行顺序：`Abc -> Demo -> web资源 -> Demo -> Abc`

过滤器链的执行顺序规则：**注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。**



### 登录校验-filter

![image-20231220172626933](assets/image-20231220172626933.png)

前端在请求服务端时，在请求头当中携带令牌，请求头的名字就叫 `token`

思考：

1. 所有的请求，拦截到了之后，都需要校验令牌吗？

    **有一个例外，登录请求**

2. 拦截到请求后，什么情况下才可以放行，执行业务操作？

    **有令牌，且令牌校验通过（合法）；否则都返回未登录错误结果**



流程：

<img src="assets/image-20231220173131750.png" alt="image-20231220173131750" style="zoom: 80%;" />

步骤：

- 获取请求url。
- 判断请求url中是否包含login，如果包含，说明是登录操作，放行。
- 获取请求头中的令牌（token）。
- 判断令牌是否存在，如果不存在，返回错误结果（未登录）。
- 解析token，如果解析失败，返回错误结果（未登录）。
- 放行。



导入阿里巴巴的相关依赖，用于将对象转为JSON格式

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.76</version>
</dependency>
```

创建一个新的滤波器类

LoginCheckFilter.java

```java
@Slf4j
@WebFilter(urlPatterns = "/*")
public class LoginCheckFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) servletRequest;
        HttpServletResponse resp = (HttpServletResponse) servletResponse;

        //1.获取请求url。
        String url = req.getRequestURI().toString();
        log.info("请求的url: {}", url);

        //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){
            log.info("登录操作，放行...");
            filterChain.doFilter(servletRequest,servletResponse);
            return;
        }

        //3.获取请求头中的令牌（token）。
        String jwt = req.getHeader("token");

        //4.判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){
            log.info("请求头token为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换：对象 -》json ----- 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }

        //5.解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) { //jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败，返回为登录的错误信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换：对象 -》json ----- 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }

        //6.放行。
        log.info("令牌合法，放行");
        filterChain.doFilter(servletRequest,servletResponse);
    }
}
```

测试：

![image-20231220190023983](assets/image-20231220190023983.png)



## 6.4 拦截器Interceptor

### 简介&快速入门

概述

- 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。

- 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。

![image-20231220190543139](assets/image-20231220190543139.png)



快速入门：

1. 定义拦截器，实现HandlerInterceptor接口，并重写其所有方法。

2. 注册拦截器

LoginCheckInterceptor.java

```java
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override //目标资源方法运行前运行，返回true：放行，返回false：不放行
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle ...");
        return true;
    }

    @Override //目标资源方法运行后运行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ...");
    }

    @Override  //视图渲染完毕后运行，最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion ...");
    }
}
```

编写配置类，注册拦截器

```java
@Configuration //配置类
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //路径要使用两个*
        registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**");
    }
}
```



### 详解(拦截路径、执行流程)

**拦截路径：**

拦截器可以根据需求，配置不同的拦截路径：

![image-20231220202730199](assets/image-20231220202730199.png)

```java
registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**").excludePathPatterns("/login");
```



| 拦截路径  | 含义                 | 举例                                                    |
| --------- | -------------------- | ------------------------------------------------------- |
| /*        | 一级路径             | 能匹配/depts，/emps，/login，==不能匹配 /depts/1==      |
| /**       | 任意级路径           | 能匹配/depts，/depts/1，/depts/1/2                      |
| /depts/*  | /depts下的一级路径   | 能匹配/depts/1，==不能匹配/depts/1/2，/depts==          |
| /depts/** | /depts下的任意级路径 | 能匹配/depts，/depts/1，/depts/1/2，==不能匹配/emps/1== |



**执行流程：**

![image-20231220203351856](assets/image-20231220203351856.png)



![image-20231220203804852](assets/image-20231220203804852.png)

**Filter** **与** **Interceptor**

- **接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。**

- **拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。**



### 登录校验Interceptor

<img src="assets/image-20231220204033047.png" alt="image-20231220204033047" style="zoom:80%;" />

<img src="assets/image-20231220204042974.png" alt="image-20231220204042974" style="zoom: 67%;" />

```java
@Slf4j
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override //目标资源方法运行前运行，返回true：放行，返回false：不放行
    public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception {
        System.out.println("preHandle ...");

        //1.获取请求url。
        String url = req.getRequestURI().toString();
        log.info("请求的url: {}", url);

        //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){
            log.info("登录操作，放行...");
            return true;
        }

        //3.获取请求头中的令牌（token）。
        String jwt = req.getHeader("token");

        //4.判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){
            log.info("请求头token为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换：对象 -》json ----- 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return false;
        }

        //5.解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) { //jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败，返回为登录的错误信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换：对象 -》json ----- 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return false;
        }

        //6.放行。
        log.info("令牌合法，放行");
        return true;

    }

    @Override //目标资源方法运行后运行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ...");
    }

    @Override  //视图渲染完毕后运行，最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion ...");
    }
}
```



# 7、异常处理

程序开发过程中不可避免的会遇到异常现象

当新增的部门名称重复时：

![image-20231220205514163](assets/image-20231220205514163.png)

出现异常，该如何处理?

- 方案一：在Controller的方法中进行try…catch处理（代码臃肿，不推荐）

- 方案二：全局异常处理器（简单、优雅，推荐）

<img src="assets/image-20231220205601804.png" alt="image-20231220205601804" style="zoom:80%;" />

<img src="assets/image-20231220205615046.png" alt="image-20231220205615046" style="zoom:80%;" />

响应的是Result对象，而前端需要的是Json，这个Result是怎么转换为Json的呢？

这是由于我的所加的 `@RestControllerAdvice`

![image-20231220205808505](assets/image-20231220205808505.png)

**`@ResponseBody` 底层会将方法的返回值转成 Json，在响应回去**

GlobalExceptionHandler.java

```java
/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class) //表示捕获所有异常
    public Result ex(Exception ex){
        ex.printStackTrace();
        return Result.error("对不起，操作失败，请联系管理员");
    }
}
```



总结：

1. 全局异常处理器

    - `@RestControllerAdvice`

    - `@ExceptionHandler`



# 8、事务管理

## 事务回顾

概念：

**事务** 是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。



操作：

- 开启事务（一组操作开始前，开启事务）：start transaction / begin ;

- 提交事务（这组操作全部成功后，提交事务）：commit ;

- 回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;



## 事务管理

解散部门：删除部门，同时删除该部门下的员工

完善删除部门功能，删除部门的同时，删除该部门下的所有员工

![image-20231220211024480](assets/image-20231220211024480.png)

![image-20231220211036010](assets/image-20231220211036010.png)

解决方案：将处理代码放在一个事务当中

使用注解：`@Transactional`

![image-20231220220716660](assets/image-20231220220716660.png)



**Spring事务管理**

![image-20231220220855386](assets/image-20231220220855386.png)

一般会在业务层使用该注解，因为在业务层中，一个业务功能可能会包含多个数据访问的操作

![image-20231220221026306](assets/image-20231220221026306.png)

`@Transactional` 注解可以作用在接口上，也可以作用在类上，交由springboot处理



在 `application.yml` 中添加如下配置

```yaml
#开启事务管理日志
logging:
  level:
    org.springframework.jdbc.support.JdbcTransactionManager: debug
```

添加注解：`@Transactional`

![image-20231220222148090](assets/image-20231220222148090.png)

测试，在前端页面中，删除教研部部门

![image-20231220222410457](assets/image-20231220222410457.png)



## 事务进阶-rollbackFor

rollbackFor：默认情况下，只有出现 **RuntimeException** 才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务。



如下情况，不是运行时异常，因此不会回滚

```java
@Transactional //spring事物管理
@Override
public void delete(Integer id) throws Exception {

    deptMapper.deleteById(id);//根据ID删除部门数据

    //int i = 1/0;
    if(true){
        throw new Exception("出错啦...");
    }

    empMapper.deleteByDeptId(id); //根据部门ID删除该部门下的员工

}
```

rollbackFor属性用于控制出现何种异常类型，回滚事务。

```java
@Transactional(rollbackFor = Exception.class)
```

表示出现所有的异常都会进行事务的回滚。



## 事务进阶-propagation

propagation - 传播行为

- 事务传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。

![image-20231220223458648](assets/image-20231220223458648.png)

执行b方法时，新建一个事务，还是加入a方法的事务？

可以通过 propagetion 属性配置。

| **属性值**    | **含义**                                                     |
| ------------- | ------------------------------------------------------------ |
| REQUIRED      | 【默认值】需要事务，有则加入，无则创建新事务                 |
| REQUIRES_NEW  | 需要新事务，无论有无，总是创建新事务                         |
| SUPPORTS      | 支持事务，有则加入，无则在无事务状态中运行                   |
| NOT_SUPPORTED | 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 |
| MANDATORY     | 必须有事务，否则抛异常                                       |
| NEVER         | 必须没事务，否则抛异常                                       |
| …             |                                                              |



案例：解散部门时，记录操作日志

需求：解散部门时，无论是成功还是失败，都要记录操作日志。

步骤：

 ①. 解散部门：删除部门、删除部门下的员工

 ②. 记录日志到数据库表中

DeptServiceImpl.java

```java
@Transactional(rollbackFor = Exception.class) //spring事物管理
@Override
public void delete(Integer id) throws Exception {

    try {
        deptMapper.deleteById(id);//根据ID删除部门数据

        int i = 1/0;
        //if (true) {throw new Exception("出错啦...");}

        empMapper.deleteByDeptId(id); //根据部门ID删除该部门下的员工

    } finally {
        DeptLog deptLog = new DeptLog();
        deptLog.setCreateTime(LocalDateTime.now());
        deptLog.setDescription("执行了解散部门的操作，此次解散的是"+id+"号部门");
        deptLogService.insert(deptLog);
    }
}
```

DeptLogService.java

```java
public interface DeptLogService {
    public void insert(DeptLog deptLog);
}
```

DeptLogServiceImpl.java

```java
@Service
public class DeptLogServiceImpl implements DeptLogService {

    @Autowired
    private DeptLogMapper deptLogMapper;

    @Transactional
    @Override
    public void insert(DeptLog deptLog) {
        deptLogMapper.insert(deptLog);
    }
}
```

DeptLogMapper.java

```java
@Mapper
public interface DeptLogMapper {

    @Insert("insert into tlias.dept_log(create_time, description) values (#{createTime},#{description})")
    void insert(DeptLog deptLog);
}
```

分析：

此时，DeptServiceImpl中的方法有一个事务管理，而其调用的 `deptLogService.insert(deptLog)` 也是由一个事务管理，此时就涉及到了事务的传播行为。

启动服务，测试：

使用插件：控制台日志过滤插件 —— Grep Console

![image-20231221003232900](assets/image-20231221003232900.png)

添加高亮

![image-20231221003436543](assets/image-20231221003436543.png)

==可以看到，默认情况下，事务的传播行为为加入到一个已存在的事务当中==

![image-20231221003604956](assets/image-20231221003604956.png)



**修改事务的传播行为**

```java
@Service
public class DeptLogServiceImpl implements DeptLogService {

    @Autowired
    private DeptLogMapper deptLogMapper;

    //设置为开启一个新的事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void insert(DeptLog deptLog) {
        deptLogMapper.insert(deptLog);
    }
}
```

测试：

![image-20231221004125160](assets/image-20231221004125160.png)



总结：

![image-20231221004235431](assets/image-20231221004235431.png)

![image-20231221004257897](assets/image-20231221004257897.png)





# 9、AOP基础

## 9.1 AOP概述

**AOP：** Aspect Oriented Programming（==面向切面编程、面向方面编程==），其实就是面向特定方法编程。

**场景：** 案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时

![image-20231221004728914](assets/image-20231221004728914.png)

将公共的部分定义在模板方法中

![image-20231221004831432](assets/image-20231221004831432.png)

**实现：** 动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。



## 9.2 AOP快速入门

Spring AOP快速入门：统计各个业务层方法执行耗时

步骤：

1、导入依赖：在pom.xml中导入AOP的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

2、编写AOP程序：针对于特定方法根据业务需要进行编程

```java
@Slf4j
@Component
@Aspect
public class TimeAspect {

    @Around("execution(* com.lyb.service.*.*(..))") //切入点表达式
    public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable {
        //1. 记录开始时间
        long begin = System.currentTimeMillis();

        //2. 调用原始方法
        Object result = joinPoint.proceed();

        //3. 记录结束时间，计算方法耗时
        long end = System.currentTimeMillis();
        log.info(joinPoint.getSignature()+"方法执行耗时：{}ms", end-begin);

        return result;
    }
}
```



总结：

![image-20231221011320439](assets/image-20231221011320439.png)

1、可以在不改变原始方法的基础上，针对于原始的方法进行编程。可以是功能的增强，也可以是功能的改变。

2、底层就是动态代理机制，对特定的方法进行编程



## 9.2 AOP核心概念

- **连接点**：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）

- **通知**：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）

- **切入点**：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用

- **切面**：Aspect，描述通知与切入点的对应关系（通知+切入点）

- **目标对象**：Target，通知所应用的对象

![image-20231221013718291](assets/image-20231221013718291.png)



执行流程：

会自动生成目标对象的代理对象，在依赖注入的时候注入的就不是目标对象而是代理对象了。

![image-20231221013925844](assets/image-20231221013925844.png)



## 9.3 AOP进阶

### 通知类型

通知类型：

1. `@Around`：环绕通知，此注解标注的通知方法在目标方法前、后都被执行

2. `@Before`：前置通知，此注解标注的通知方法在目标方法前被执行

3. `@After`：后置通知，此注解标注的通知方法在目标方法后被执行，==无论是否有异常都会执行==

4. `@AfterReturning` ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行

5. `@AfterThrowing` ： 异常后通知，此注解标注的通知方法发生异常后执行



注意事项：

- `@Around` 环绕通知需要自己调用 `ProceedingJoinPoint.proceed()` 来让原始方法执行，其他通知不需要考虑目标方法执行

- `@Around` 环绕通知方法的返回值，必须指定为 Object，来接收原始方法的返回值。



`@PointCut` ：该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。

![image-20231221015318283](assets/image-20231221015318283.png)





### 通知顺序

当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。

执行顺序：

1. 不同切面类中，默认按照切面类的==类名字母排序==：

    - 目标方法前的通知方法：字母排名靠前的先执行

    - 目标方法后的通知方法：字母排名靠前的后执行

2. 用 `@Order(数字)` 加在切面类上来控制顺序

    - 目标方法前的通知方法：数字小的先执行

    - 目标方法后的通知方法：数字小的后执行

![image-20231221015838377](assets/image-20231221015838377.png)

![image-20231221015848970](assets/image-20231221015848970.png)



### 切入点表达式

切入点表达式：描述切入点方法的一种表达式

作用：主要用来决定项目中的哪些方法需要加入通知

常见形式：

1. `execution(……)`：根据方法的签名来匹配

2. `@annotation(……)` ：根据注解匹配

![image-20231221141231170](assets/image-20231221141231170.png)



**execution**

execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：

```java
execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)
```

其中带 ? 的表示可以省略的部分

- 访问修饰符：可省略（比如: public、protected）

- 包名.类名： 可省略

- throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）

![image-20231221142009888](assets/image-20231221142009888.png)

可以使用通配符描述切入点

- `*`：**单个独立的任意符号**，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分

```java
execution(* com.*.service.*.update*(*))
```

- `..` ：**多个连续的任意符号**，可以通配任意层级的包，或任意类型、任意个数的参数

```java
execution(* com.itheima..DeptService.*(..))
```



![image-20231221142724101](assets/image-20231221142724101.png)

书写建议：

- 所有业务**方法名**在**命名**时**尽量规范**，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是 update开头。

- 描述切入点方法通常**基于接口描述**，而不是直接描述实现类，**增强拓展性**。

- 在满足业务需要的前提下，**尽量缩小切入点的匹配范围**。如：包名匹配尽量不使用 ..，使用 * 匹配单个包。



**@annotation**

@annotation 切入点表达式，用于匹配**标识有特定注解的方法**。

![image-20231221143129386](assets/image-20231221143129386.png)

![image-20231221143134373](assets/image-20231221143134373.png)

自定义注解：

![image-20231221143330046](assets/image-20231221143330046.png)



### 连接点

在Spring中用 **JoinPoint** 抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。

- 对于 @Around 通知，获取连接点信息只能使用 `ProceedingJoinPoint`

- 对于其他四种通知，获取连接点信息只能使用 `JoinPoint` ，**它是 ProceedingJoinPoint 的父类型**

![image-20231221143736664](assets/image-20231221143736664.png)

![image-20231221143739222](assets/image-20231221143739222.png)



## 9.4 AOP案例-记录操作日志

将案例中 增、删、改 相关接口的操作日志记录到数据库表中。

![image-20231221144337256](assets/image-20231221144337256.png)



![image-20231221144601965](assets/image-20231221144601965.png)



![image-20231221144726385](assets/image-20231221144726385.png)



![image-20231221144745423](assets/image-20231221144745423.png)

```java
@Slf4j
@Component
@Aspect //切面类
public class LogAspect {

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private OperateLogMapper operateLogMapper;

    @Around("@annotation(com.lyb.anno.Log)")
    public Object recording(ProceedingJoinPoint joinPoint) throws Throwable {

        //操作人的ID - 当前登录员工的ID
        //获取请求头当中的jwt令牌，解析令牌
        String jwt = request.getHeader("token");
        Claims claims = JwtUtils.parseJWT(jwt);
        Integer operateUser = (Integer) claims.get("id");

        //操作时间
        LocalDateTime operateTime = LocalDateTime.now();

        //操作类名
        String className = joinPoint.getTarget().getClass().getName();

        //操作方法名
        String methodName = joinPoint.getSignature().getName();

        //操作方法参数
        Object[] args = joinPoint.getArgs();
        String methodParams = Arrays.toString(args);

        long begin = System.currentTimeMillis();

        //调用原始目标方法运行
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();

        //返回值
        String returnValue = JSONObject.toJSONString(result);

        //操作耗时
        Long costTime = end - begin;


        //记录操作日志
        OperateLog operateLog = new OperateLog(null,operateUser,operateTime,className,methodName,methodParams,returnValue,costTime);
        operateLogMapper.insert(operateLog);

        log.info("AOP记录操作日志：{}", operateLog);

        return result;
    }

}
```

























