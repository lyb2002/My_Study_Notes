# Java基础篇

# 1、入门

## 1.1 java工具

下载好java后，在bin目录下有两个工具是我们需要用到的：

- javac ：编译
- java ：运行
- javap：反编译
- jhsdb：内存测试工具

使用javac编译.java文件后，会生成.class文件。

使用java运行文件（不带后缀）

```bash
javac HelloWorld.java
java Helloworld
```

1. 编译：`javac`是Java编译器命令，用于将Java源代码编译成字节码文件（也就是class文件）。在编译Java文件时，需要指定源文件的文件名并加上`.java`后缀，以告诉编译器要编译的文件是哪个。例如：`javac HelloWorld.java`。
2. 运行：`java`是Java虚拟机的命令，用于执行已经编译好的class文件。==在运行class文件时，只需要指定类名即可，不需要加上后缀==。这是因为Java虚拟机会自动查找并加载与类名相同的class文件，并执行其中的主方法。例如：`java HelloWorld`。

在Java中，类名和文件名通常是一一对应的，这是因为Java编程规范要求类名与文件名保持一致。



## 1.2 环境变量

**jdk17不用手动配置环境变量**

安装java时，把 `java，javac，javaw，jshell` 放到了（相当于快捷方式）如下路径 ：`C:\Program Files\Common Files\Oracle\Java\javapath` ，再将该路径配置系统的环境变量中 。

![image-20231003145715592](assets/image-20231003145715592.png)

但是java自动配置的环境只包含了四个工具，因此要使用其他工具，还是需要手动配置环境变量。

配置方法：

1、新建变量，变量名为 `JAVA_HOME` ，值为java的安装路径。（不带bin）

![image-20231003150049554](assets/image-20231003150049554.png)

2、在系统环境变量Path中添加如下变量：`%JAVA_HOME%\bin`

![image-20231003150157557](assets/image-20231003150157557.png)







## 1.3 跨平台和特性

java 三大类：

- **Java SE** ：Java 语言的（标准版），用于**桌面应用的开发**，是其他两个版本的基础。

    > 学习目的：为将来从事的 Java EE 的开发打基础
    >
    > 桌面应用：用户只要打开程序，程序的界面会让用户在最短的时间内找到他们需要的功能，同时主动带领用户完成他们的工作并得到最好的体验。

- **Java ME** ：Java 语言的（小型版），用于嵌入式电子设备或者小型移动设备。

- **Java EE** ：Java 语言的（企业版），用于 Web 方向的**网站**开发。在这个领域，是当之无愧的的No1。

    > 网站开发：浏览器+服务器



java特性：

- 面向对象
- 安全性
- 多线程
- 简单易用
- 开源
- 跨平台



跨平台：java可以在任何操作系统运行（Write Once Run Anywhere）

- Windows
- macOS
- Linux



跨平台原理：

高级语言的编译运行方式：

- ==编程==：java程序员写的.java代码，c程序员写的.c代码，python程序员写的.py代码

- ==编译==：机器只认识0011的机器语言，把.java .c .py的代码做转化让机器认识的过程
- ==运行==：让机器执行编译后的指令

高级语言的编译运行方式：

- 编译型
- 解释性
- 混合型，半编译，半解释

编译型：

<img src="assets/image-20230713121337538.png" alt="image-20230713121337538" style="zoom: 33%;" />

<img src="assets/image-20230713121410042.png" alt="image-20230713121410042" style="zoom: 33%;" />

解释型：

<img src="assets/image-20230713121446001.png" alt="image-20230713121446001" style="zoom: 33%;" />

<img src="assets/image-20230713121518594.png" alt="image-20230713121518594" style="zoom: 33%;" />

混合型：（java）

<img src="assets/image-20230713132442775.png" alt="image-20230713132442775" style="zoom: 33%;" />

java 跨平台原理：

<img src="assets/image-20230713132523398.png" alt="image-20230713132523398" style="zoom:50%;" />

- **Java语言的跨平台是通过虚拟机实现的。**
- Java语言不是直接运行在操作系统里面的，而是运行在虚拟机中的。
- 针对于不同的操作系统，安装不同的虚拟机就可以了。



## 1.4 JRE和JDK

**JVM**（java Virtual Machine）：java的虚拟机，真正运行java程序的地方

**核心类库**：java事先定义好的类

**开发工具**：

- javac编译工具
- java运行工具
- jdb调试工具
- jhat内存分析工具

JDK：JVM、核心类库和开发工具组成的整体

JDK（Java Development kit）：Java**开发工具包**

<img src="assets/image-20230713134144380.png" alt="image-20230713134144380" style="zoom: 67%;" />

JRE（Java Runtime Environment）：java的**运行环境**

只需要运行工具，不需要编译工具

<img src="assets/image-20230713134521169.png" alt="image-20230713134521169" style="zoom:67%;" />

**JDK、JRE和JVM三者的包含关系：**

- **JDK包含了JRE**
- **JRE包含了JVM**



## 1.4 HelloWorld案例

```java
public class HelloWorld{
    public static void main(String[] args){
        System.out.println("HelloWorld");
    }
}
```





# 2、基础概念

==java文件的类名和文件名要一样==

## 2.1 注释

注释分类：

- 单行注释

    ```java
    //注释信息
    ```

- 多行注释

    ```java
    /*注释信息*/
    ```

- 文档注释

    ```java
    /** 注释信息**/
    ```


注释内容不会参与编译与运行，仅仅是对代码的解释说明。



## 2.2 关键字

关键字：被Java赋予了特定涵义的英文单词

- 关键字的字母==全部小写==。

- class：用于（创建/定义）一个类，类是Java最基础的组成单元

| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |
| -------------- | ---------------- | ------------- | -------------- | ---------- |
| **case**       | **catch**        | **char**      | **class**      | **const**  |
| **continue**   | **default**      | **do**        | **double**     | **else**   |
| **enum**       | **extends**      | **final**     | **finally**    | **float**  |
| **for**        | **goto**         | **if**        | **implements** | **import** |
| **instanceof** | **int**          | **interface** | **long**       | **native** |
| **new**        | **package**      | **private**   | **protected**  | **public** |
| **return**     | **strictfp**     | **short**     | **static**     | **super**  |
| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |
| **transient**  | **try**          | **void**      | **volatile**   | **while**  |



## 2.3 字面量

告诉程序员：数据在程序中的书写格式

| 字面量类型 |               说明               |            举例             |
| :--------: | :------------------------------: | :-------------------------: |
|  整数类型  |         不带小数点的数字         |          666, -88           |
|  小数类型  |          带小数点的数字          |        13.14, -5.21         |
| 字符串类型 |       用双引号括起来的内容       | "Hello World", "黑马程序员" |
|  字符类型  | 用单引号括起来的，内容只能有一个 |       'A', '0', '我'        |
|  布尔类型  |         布尔值，表示真假         |   只有两个值：true, false   |
|   空类型   |        一个特殊的值，空值        |            null             |

特殊类型：`\t, \n, \r.....`

- `\t` ：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。

    ```java
    System.out.println("name" + '\t' + "age");
    ```

    

## 2.4 变量

数据类型 变量名 = 数据值;

```java
public class VariableDemo1{
    public static void main(String[] args){
    	int a = 10;  
        int b = 10;
        System.out.println(a+b);
    }
}
```



## 2.5 计算机中的数据存储

在计算机中，任意数据都是以二进制的形式来存储的

- 二进制：0b
- 八进制：0
- 十六进制：0x

十进制转其他进制：

除基取余法：不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。



## 2.6 基本数据类型

基本数据类型和整数数据类型

| 数据类型 | 关键字  | 取值范围                                 | 内存占用 |
| :------: | :-----: | :--------------------------------------- | :------: |
|   整数   |  byte   | -128~127                                 |    1     |
|          |  short  | -32768~32767                             |    2     |
|          |   int   | -2147483648~2147483647                   |    4     |
|          |  long   | -9223372036854775808~9223372036854775807 |    8     |
|  浮点数  |  float  | -3.401298e-38 到 3.402823e+38            |    4     |
|          | double  | -4.9000000e-324 到 1.797693e+308         |    8     |
|   字符   |  char   | 0-65535                                  |    2     |
|   布尔   | boolean | true, false                              |    1     |

- long 类型变量：需要加入 L 标识（大小写都可以）

- float 类型变量：需要加入 F 标识（大小写都可以）

- 字符串：String
- e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。
- 在java中整数默认是int类型，浮点数默认是double类型。



## 2.7 标识符

业内大多数程序员都在遵守**阿里巴巴**的命名规则。

**硬性要求：**

- 由数字、字母、下划线（_）和美元符（$）组成
- 不能以数字开头
- 不能是关键字
- 区分大小写

**软性建议：**

- ==小驼峰命名法：方法、变量==

    规范1：标识符是一个单词的时候，全部小写

    范例1：name

    规范2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写

    范例2：firstName

- ==大驼峰命名法：类名==

    规范1：标识符是一个单词的时候，首字母大写

    范例1：Student

    规范2：标识符由多个单词组成的时候，每个单词的首字母大写

    范例2：GoodStudent

**阿里巴巴命名规范细节：**

- 尽量不要用拼音。
- 平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。



## 2.7 键盘录入

- Java帮我们写好了一个类叫Scanner，这个类就可以接收键盘输入的数字。

使用步骤：

1. 导包 —— Scanner这个类在哪

    ```java
    import java.util.Scanner;
    ```

2. 创建对象 —— 表示我要开始使用Scanner这个类了

    ```java
    Scanner sc = new Scanner(System.in);
    ```

3. 接收数据 —— 真正开始干活了

    ```java
    int i = sc.nextInt();
    ```




## 2.8 输出

```java
// 输出内容并换行
System.out.println();
// 输出内容不换行
System.out.print();
// 格式化输出
System.out.printf();
```



# 3、IDEA

Intellij IDEA，是用于java语言开发的集成环境，它是业界公认的目前用于java程序开发最好的工具。

下载：[IntelliJ IDEA – the Leading Java and Kotlin IDE (jetbrains.com)](https://www.jetbrains.com/idea/)

**项目结构：**

- project（项目）
- module（模块）
- package（包）
- class（类）



包的命名：公司域名反写+功能 `com.itheima.demo1`

==快速生成main函数：`psvm`==

==快速生成输出函数：`sout`==



==设置自动导包：Settings -> Editor -> General -> Auto Import==

![image-20231003162619377](assets/image-20231003162619377.png)

IDEA 类的操作：新建类、删除类、修改类名

IDEA 模块的操作：新建模块、删除模块、修改模块、导入模块

IDEA 模块的操作：关闭项目、新建项目、打开项目、修改项目



# 4、运算符

运算符：对字面量或变量进行操作的符号。

表达式：用运算符把字面量或者变量连接起来，符合java语法的句子就可以称为表达式。

- 算术运算符
- 自增自减运算符
- 赋值运算符
- 关系运算符
- 逻辑运算符
- 三元运算符
- 运算符优先级

## 4.1算术运算符

- \+	加
- \-     减
- \*    乘 
- /     除
- %   取模、取余

## 4.2 隐式转换和强制转换

不同数据类型不能直接做运算

隐式转换：

- 把一个取值范围小的数值，转换成取值范围大的数据
- byte -》short -》int -》long -》float -》double
- byte、short 、char 三种类型运算时，都会直接先提升为int，再进行运算

强制转换：

- 格式：目标数据类型 变量名 = ( 目标数据类型 ) 被强转的数据;

## 4.3 字符串和字符的加操作

字符串：

- 当 "+" 操作中出现字符串时，这个 "+" 是字符串连接符，而不是算术运算符了。

- ==连续进行 "+" 操作时，从左到右逐个执行。==

    1 + 99 + "年黑马"     ——》 "100年黑马"

    1 + 2 + "abc" + 2 + 1 ——》 "3abc21"

字符：

- ==字符 + 字符 或 字符 + 数字== ，会把字符通过ASCII码表查询到对应的数字再进行计算。

    1 + 'a' ——》 98

    'a' + "abc" ——》"aabc"

## 4.4 自增自减运算符

- ++、--
- 先加和后加，单独写一行结果是一样的，有赋值操作时有区别。

## 4.5 赋值和关系运算符

赋值运算符：扩展的运算符底层隐藏了一个强制转换

- =、+=、-=、*=、/=、%=
- ==、!=、>、>=、<、<=

## 4.6 逻辑运算符

- &、|、^、!

## 4.7 短路逻辑运算符

- &&、||
- ==当前一个表达式已经能够得出整个表达式的结果时，不会执行后面的表达式==

## 4.8 三元运算符

格式：

- 关系表达式？表达式1：表达式2；

## **4.9 原码反码补码**

[运算符-12-多学一招原码反码补码_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17F411T7Ao/?p=38&spm_id_from=pageDriver&vd_source=9ee4e4e88a104cb8b17a1c0f21495c43)

- **原码**：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。

    利用原码对正数进行计算是不会有问题的。

    但是如果是负数计算，结果就出错，实际运算的结果，跟我们预期的结果是相反的。

- **反码**：为了解决原码不能计算负数的问题而出现的。

    正数的反码不变，负数的反码在原码的基础上，符号位不变，数值取反，0变1,1变0 。

    ==反码可以完美解决负数计算的问题。==

    ==问题：会出现两个0 , `1000 0000` 和 `0000 0000` 。因此跨0会产生1个误差==

- 补码：在反码的基础上加1。

    ==补码完美解决正数和负数的计算问题。==

    为了解决负数计算时跨0的问题而出现的。

正数的原、反、补码都是一样的。

![image-20230715173738424](assets/image-20230715173738424.png)

![image-20230715174018175](assets/image-20230715174018175.png)

其他运算符：

- &	  逻辑与
- |       逻辑或
- <<     左移
- \>\>     右移
- \>\>\>   无符号右移



# 5、判断与循环结构

## 5.1 if语句

格式：

```java
// 格式1
if(关系表达式){
    语句体;  
}

// 格式2
if(关系表达式){
    语句体1;  
}else{
    语句体2;
}

// 格式3
if(关系表达式){
    语句体1;  
}else if(关系表达式){
    语句体2;
}else{
    语句体3;
}
```

## 5.2 switch语句

格式：

```java
switch(表达式){
    case 值1:
        语句体1；
        break;
    case 值2:
        语句体2；
        break;
    ...
    default:
        语句体n+1;
        break;
}
```

- case 后面的值只能是字面量，不能是变量
- case 给出的值不允许重复

==switch新特性：jdk12==

```java
int number = 1;
switch(number){
    case 1 -> {
        System.out.println("一");
    }
    case 2 -> {
        System.out.println("二");
    }
    case 3 -> {
        System.out.println("三");
    }
    default -> {
        System.out.println("无");
    }
}

// 或者
switch(number){
    case 1 -> System.out.println("一");

    case 2 -> System.out.println("二");

    case 3 -> System.out.println("三");
    default -> System.out.println("无");
}
```



## 5.3 for语句

格式：

```java
for(int i = 1;i <= 10;i++){
    System.out.println("Hello World");
}
```

## 5.4 while循环

格式：

```java
while(条件判断语句){
    循环体语句;
    条件控制语句;
}
```

## 5.5 do...while循环

```java
do{
    循环体语句；
    条件控制语句；
}while(条件判断语句)；
```



## 5.6 break和continue

- break：结束整个循环
- continue：跳过本次循环



## 5.7 生成随机数

```java
import java.util.Random
    
Random r = new Ramdom();

int number = r.nextInt(随机数的范围);
```



# 6、数组

## 6.1 数组定义和静态初始化

格式：

```java
// 格式一
int [] array;
// 格式二
int array[];
```

**静态初始化**：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

格式：

```java
// 完整格式
int[] array = new int[]{ 11, 22, 33};
// 简化格式
int[] array = { 11, 22, 33};
double[] array2 = { 11.1, 22.2, 33.3};
```

**数组一旦创建之后，长度不能发生变化。**



## 6.2 数组的地址值和元素访问

地址值

```java
int[] array = { 11, 22, 33};
System.out.println(array); //[I@776ec8df 地址值
//[ : 表示当前是一个数组
//D : 表示当前数组里面的元素都是double类型
//I : 表示当前数组里面的元素都是int类型
//@ : 表示一个间隔符号。（固定格式）
//776ec8df : 数组的真正地址值
```

元素访问

```java
数组名[索引]
```



## 6.3 数组遍历

数组的长度：数组名.length

自动的快速生成数组的遍历方式 idea提供的：数组名.fori

```java
int[] arr = {1,2,3,4,5};
// 在java中，关于数组的一个长度属性：length
// 调用方式：数组名.length
for(int i=0; i<arr.length; i++){
    System.out.println(arr[i]);
}

// 扩展：
// 自动的快速生成数组的遍历方式
// idea提供的
// 数组名.fori
arr.fori
```



## 6.4 数组的动态初始化

**初始化时只指定数组长度，由系统为数组分配初始值。**

格式：

```java
数据类型[] 数组名 = new 数据类型[数组长度];
int[] a = new int[3];
String[] arr = new String[50];
```

数组默认初始化值的规律：

- 整数类型：默认初始化值0
- 小数类型：默认初始化值0.0
- 字符类型：默认初始化值 '/u0000' 空格
- 布尔类型：默认初始化值false
- 引用数据类型：默认初始化值 null



## 6.5 数组的内存图

![image-20231003174749759](assets/image-20231003174749759.png)

- 栈：方法运行时使用的内存，比如main方法运行，进入方法栈中执行
- 堆：存储对象或者数组，new来创建的，都存储在堆内存
- 方法区.：存储可以运行的class文件
- 本地方法栈：JVM在使用操作系统功能的时候使用，和我们开发无关
- 寄存器：给CPU使用，和我们开发无关

![image-20231003175217830](assets/image-20231003175217830.png)

1、只要是new出来的一 定是在堆里面开辟了一个小空间

2、如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据

![image-20231003175426265](assets/image-20231003175426265.png)

当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。



## 6.6 二维数组

格式：

```java
数据类型[][] 数组名 = new 数据类型[][]{{元素1},{元素2}};
数据类型[][] 数组名 = {{元素1},{元素2}};
```

范例：

```java
int[][] arr = new int[][]{{11,22},{33,44}};
int[][] arr = {{11,22},{33,44}};
```

动态初始化格式：

```java
数据类型[][] 数组名 = new 数据类型[m][n];
```

![image-20231004141158103](assets/image-20231004141158103.png)

可以自己创建一维数组，一维数组长度可以不一样

![image-20231004141413039](assets/image-20231004141413039.png)



# 7、方法

## 7.1 什么是方法？

方法（method）是程序中最小的执行单元。

作用：

- 提高代码的复用性

- 提供代码可维护性

## 7.2 方法的定义和调用

* 方法必须先创建才可以使用，该过程成为方法定义
* 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用



- **方法定义**：把一些代码打包在一起，该过程成为方法定义。
- **方法调用**：方法定义后并不是直接运行的，需要手动调用才能执行，该过程称为方法调用。



最简单的方法定义和调用

格式：

```java
public static void 方法名(){
    方法体（就是打包起来的代码）;
}
```

调用：

```java
方法名（）;
```



实例：

```java
package com.itheima.methoddemo;

public class MethodDemo3 {
    public static void main(String[] args){
        getSum();
    }
    
    public static void getSum(){
        int num1 = 10;
        int num2 = 20;
        int result = num1 + num2;
        System.out.println(result);
    }
}
```



## 7.3 带参数的方法

定义格式：

```java
public static void 方法名（参数1，参数2，...）{
    ...
}
```

调用格式：

```java
方法名（参数1，参数2，...）；
```

注意：方法调用时，参数的数量与类型必须与方法定义中小括号里面的变量一一对应，否则程序将报错。



## 7.4 带返回值的方法

格式：

```java
public static 返回值类型 方法名 （参数）{
    方法体；
    return 返回值；
}
```

调用：

```java
// 直接调用
方法名（实参）;
// 赋值调用
整数类型 变量名 = 方法名（实参）;
// 输出调用
System.out.println(方法名（实参）);
```



## 7.5 方法重载

- 在同一个类中，定义了多个==同名的方法==，这些同名的方法具有同种的功能。
- 每个方法具有==不同的参数类型或参数个数==，这些同名的方法，就构成了重载关系

- ==与返回值无关==
- 不再同一个类中的函数，不构成重载关系

参数不同：个数不同、类型不同、顺序不同（不同形参类型）



## 7.6 方法内存

- 方法调用的基本内存原理
- 方法传递基本数据类型的内存原理
- 方法传递引用数据类型的内存原理

在Java中，所有的对象（包括整型数组）都保存在堆区。原因是 Java 的内存管理由垃圾回收器负责，无需手动释放内存，所以所有的对象都在堆区进行分配和管理。

C++里面的数组是开辟在栈的，但是用new是开在堆区的。

![image-20231003220610074](assets/image-20231003220610074.png)

==基本数据类型==：数据值是存储在自己的空间中

特点：赋值给其他变量，也是赋的真实的值。

==引用数据类型==：数据值是存储在其他空间中,自己空间中存储的是地址值。

特点：赋值给其他变量，赋的地址值。



## 7.7 方法的值传递

- 传递**基本数据类型**时，传递的是真实的数据，形参的改变，不影响实际参数的值

- 传递**引用数据类型**时，传递的是地址值，形参的改变，影响实际参数的值



在Java中，方法默认情况下是无法直接修改传入的实参的值的。==Java采用的是"按值传递"机制，即将实参的值复制一份传递给方法。==

可以通过返回值的方式将修改后的值传递回去。

```java
public class Main {
    public static void main(String[] args) {
        int value = 10;
        System.out.println("Before modify: " + value); // 输出 10
        value = modifyValue(value);
        System.out.println("After modify: " + value); // 输出 100
    }
    
    public static int modifyValue(int val) {
        return 100; // 返回修改后的值
    }
}
```

但是，你可以通过其他方式改变实参的值。其中一种方式是传递可变对象（如数组或自定义类的实例），然后在方法内部通过修改对象的成员来改变实参的值。

```java
public class Main {
    public static void main(String[] args) {
        int[] array = {1, 2, 3};
        System.out.println("Before modify: " + array[0]); // 输出 1
        modifyArray(array);
        System.out.println("After modify: " + array[0]); // 输出 100
    }
    
    public static void modifyArray(int[] arr) {
        arr[0] = 100; // 修改数组的第一个元素
    }
}
```



## 7.8 idea快速抽取方法

Ctrl+Alt+M





# 8、面向对象

## 8.1 类与对象

- 类（设计图）：是对象共同特征的描述；
- 对象：是真实存在的具体东西。
- **类是对事物的一种描述，对象则为具体存在的事物**

在java中，必须先设计类，才能获得对象

## 8.2 类的定义和使用

如何定义类

```java
public class 类名 {
    1、成员变量(代表属性, 一般是名词)
    2、成员方法(代表行为, 一般是动词)
    3、构造器
    4、代码块
    5、内部类
}
```

如何得到类的对象

```java
类名 对象名 = new 类名();
```

如何使用对象

```java
// 访问属性
对象名.成员变量
// 访问行为
对象名.方法名(...)
```

## 8.3 Javabean类和测试类

定义类的补充注意事项

- 用来描述一类事物的类，专业叫做：==Javabean类==。

    **在Javabean类中，是不写main方法的。**

- 在以前，编写main方法的类，叫做==测试类==。

    我们可以在测试类中创建javabean类的对象并进行赋值调用。

## 8.4 类的注意事项

- 类名首字母建议大写，需要见名知意，驼峰模式。

- ==**一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。**==

    **实际开发中建议还是一个文件定义一个class类。**

- 成员变量的完整定义格式是：`修饰符 数据类型 变量名称=初始化值; ` 一般无需指定初始化值，存在默认值。

对象的成员变量的默认值规则

| 数据类型 | 明细                   | 默认值 |
| -------- | ---------------------- | ------ |
| 基本类型 | byte、short、int、long | 0      |
|          | float、double          | 0.0    |
|          | boolean                | false  |
| 引用类型 | 类、接口、数组、String | null   |

## 8.5 成员变量和局部变量

* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）
* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）
* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）





## 8.6 封装

对象代表什么，就得封装对应的数据，并提供数据对应的行为

封装代码实现：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问

成员变量private，提供对应的getXxx()/setXxx()方法

## 8.7 private关键字

private是一个修饰符，可以用来修饰成员（成员变量，成员方法）

* 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作
    * 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰
    * 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰

防止给成员变量赋一个不合法的值。（使用public方法赋值）



## 8.8 就近原则和this关键字

this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）

```java
public class GirlFriend {
    private int age;
    
    public void method(){
        int age = 10;
        //谁离我近就用谁
        System.out.println(age); // 10
        System.out.println(this.age); // 0
    }
    
}
```



## 8.9 构造方法

构造方法也叫作构造器、构造函数。
作用：在创建对象的时候给成员变量进行赋值的。



特点:

- 方法名与类名相同，大小写也要一致
- 没有返回值类型，连void都没有
- 没有具体的返回值(不能由return带回结果数据)

执行时机:

- 创建对象的时候由虚拟机调用，不能手动调用构造方法
- 每创建一次对象，就会调用一次构造方法



构造方法注意事项
①构造方法的定义

- 如果没有定义构造方法，系统将给出一个默认的无参数构造方法
- 如果定义了构造方法，系统将不再提供默认的构造方法

②构造方法的重载

- 带参构造方法， 和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载

③推荐的使用方式

- 无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法



## 8.10 标准JavaBean

标准的JavaBean类：

1. 类名需要见名知意

2. 成员变量使用==private==修饰

3. 提供至少两个构造方法

    - **无参构造方法**

    - **带全部参数的构造方法**

4. 成员方法

    - **提供每一个成员变量对应的setXx()/getXxx()**

    - 如果还有其他行为， 也需要写上



快速生成 JavaBean

快捷键：

- alt + insert

- alt + Fn +insert

插件：

- ptg（在设置插件中下载）
- 下载后，右键空白处，选择 `Ptg To JavaBean`



## 8.11 三中情况的对象内存图

<img src="assets/image-20231004150420885.png" alt="image-20231004150420885" style="zoom:33%;" />

<img src="assets/image-20231004150459281.png" alt="image-20231004150459281" style="zoom: 33%;" />

一个对象的内存图：

1. 加载class文件
2. 申明局部变量
3. 在堆内存中开辟一个空间
4. 默认初始化
5. 显示初始化
6. 构造方法初始化

7. 将堆内存中的地址值赋值给左边的局部变量

![image-20231004151012242](assets/image-20231004151012242.png)

![image-20231004151153893](assets/image-20231004151153893.png)

![image-20231004151300823](assets/image-20231004151300823.png)



## 8.12 基本数据类型和引用数据类型

- 基本数据类型
    - 数据值是存储在自己空间里的
    - 特点：赋值给其他变量，也是赋的真实的值。
- 引用数据类型
    - 数据值是存储在其他空间中，自己空间中存储的是地址值。
    - 特点：赋值给其他变量，赋的地址值。



## 8.13 this的内存原理

this的作用：区分局部变量和成员变量

this的本质：所在方法调用者的地址值

![image-20231004151821600](assets/image-20231004151821600.png)



## 8.14 成员和局部变量

成员变量：类中方法外的遍历

局部变量：方法中的变量

|     区别     |                  成员变量                  |                    局部变量                     |
| :----------: | :----------------------------------------: | :---------------------------------------------: |
| 类中位置不同 |                类中，方法外                |               方法内、方法申明上                |
| 初始化值不同 |               有默认初始化值               |            没有)使用之前需要完成赋值            |
| 内存位置不同 |                   堆内存                   |                     栈内存                      |
| 生命周期不同 | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在， 随着方法的运行结束而消失 |
|    作用域    |                整个类中有效                |                 当前方法中有效                  |



# 9、字符串

## 9.1 API和API帮助文档

API (Application Programming Interface) ：应用程序编程接口

Java API：指的就是JDK中提供的各种功能的Java类

这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。



## 9.2 String概述

java.lang 是 java 的核心包，在使用时不需要导包

java.lang.String类代表字符串，Java 程序中的所有字符串文字(例如"abc" )都为此类的对象。

**字符串的值不能改变，一旦创建就不能改变**

- 虽然 String 的值是不可变的，但是它们可以被共享
- 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )



## 9.3 String构造方法

1、直接赋值

```java
String s1 = "abc";
```

2、使用new获取一个字符串对象

```java
String s2 = new String();
```

| 构造方法                       | 说明                             |
| ------------------------------ | -------------------------------- |
| public String()                | 创建空白字符串，不含任何内容     |
| public String(String original) | 根据传入的字符串，创建字符串对象 |
| public String(char[] chs)      | 根据字符数组，创建字符串对象     |
| public String(byte[] chs)      | 根据字节数组，创建字符串对象     |

直接赋值：

![image-20231004160559812](assets/image-20231004160559812.png)

当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。

- 不存在：创建新的
- 存在：复用

new：

![image-20231004160746624](assets/image-20231004160746624.png)

字符串不会复用。

- 通过构造方法创建

    ​	通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

- 直接赋值方式创建

    ​	以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护



## 9.4 字符串的比较

使用==号

![image-20231004160912762](assets/image-20231004160912762.png)

**基本数据类型比较数据值，引用数据类型比较地址值**

![image-20231004160931659](assets/image-20231004160931659.png)

使用equals方法

```java
// 完全一样结果为true，否则为false
boolean equals(要比较的字符串)
// 忽略大小写
boolean equalsIgnoreCase(要比较的字符串)
```

示例：

```java
boolean result = s1.equals(s2);
```



## 9.5 索引和长度

```java
// 根据索引返回字符
public char charAt(int index)
// 返回此字符串的长度
public int length()
// 数组的长度
数组名.length
//字符串的长度
字符串对象.length()
```



## 9.6 截取子串

```java
String substring(int beginIndex, int endIndex)
//注意点:包头不包尾，包左不包右
//只有返回值才是截取的小串
String substring(int beginIndex)	//截取到末尾
```



## 9.7 替换

```java
String replace(旧值,新值)	//替换
//注意点:只有返回值才是替换之后的结果
```



## 9.8 StringBuilder

StringBuilder可以看成是一个容器， 创建之后里面的内容是可变的

作用：提高字符串的操作效率

当我们在拼接字符串和反转字符串的时候会使用到

构造方法：

| 方法名                           | 说明                                       |
| -------------------------------- | ------------------------------------------ |
| public StringBuilder()           | 创建一个空白可变字符串对象，不含有任何内容 |
| public StringBuilder(String str) | 根据字符串的内容,来创建可变字符串对象      |

常用方法：

| 方法名                                 | 说明                                               |
| -------------------------------------- | -------------------------------------------------- |
| public StringBuilder append (任意类型) | 添加数据，并返回对象本身                           |
| public StringBuilder reverse()         | 反转容器中的内容                                   |
| public int length()                    | 返回长度(字符出现的个数)                           |
| public String toString()               | 通过toString(就可以实现把StringBuilder转换为String |



## 9.9 StringJoiner

- StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。
- 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。
- JDK8出现的

| 方法名                                             | 说明                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| public StringJoiner (间隔符号)                     | 创建一个StringJoiner对象， 指定拼接时的间隔符号              |
| public StringJoiner (间隔符号，开始符号，结束符号) | 创建一个StringJoiner对象， 指定拼接时的间隔符号、开始符号、结束符号 |

示例：

```java
//1.创建一个对象，并指定中间的间隔符号
StringJoiner sj = new StringJoiner("---");
//2.添加元素
sj.add("aaa").add("bbb").add("ccc");
//3.打印结果
System.out.println(sj);//aaa---bbb---ccc

//1.创建对象
StringJoiner sj = new StringJoiner(", ","[","]");
//2.添加元素
sj.add("aaa").add("bbb").add("ccc");
int len = sj.length();
System.out.println(len);//15
//3.打印
System.out.println(sj);//[aaa, bbb, ccc]
String str = sj.toString();
System.out.println(str);//[aaa, bbb, ccc]
```

成员方法：

| 方法名                               | 说明                                       |
| ------------------------------------ | ------------------------------------------ |
| public StringJoiner add (添加的内容) | 添加数据，并返回对象本身                   |
| public int length()                  | 返回长度(字符出现的个数)                   |
| public String toString()             | 返回一个字符串(该字符串就是拼接之后的结果) |



## 9.10 字符串底层原理

扩展底层原理1：字符串存储的内存原理

- 直接赋值会复用字符串常量池中的

- new出来不会复用，而是开辟一个新的空间

扩展底层原理2：==号比较的到底是什么?

- 基本数据类型比较 数据值
- 引用数据类型比较 地址值

扩展底层原理3：字符串拼接的底层原理

- 拼接的时候没有变量，都是字符串

- 触发字符串的优化机制。

- 在编译的时候就已经是最终的结果了。

![image-20231004235049980](assets/image-20231004235049980.png)

有变量参与：

- 一个加号，堆内存中两个对象

![image-20231004235204094](assets/image-20231004235204094.png)

![image-20231004235310045](assets/image-20231004235310045.png)

JDK8字符串拼接的底层原理：预估拼接后字符串长度。

字符串拼接的时候有变量参与:

- 在内存中创建了很多对象
- 浪费空间，时间也非常慢

结论:

- 如果很多字符串变量拼接,不要直接+。在底层会创建多个对象，浪费时间，浪费性能。
- 如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。
- 如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串浪费内存。



扩展底层原理4：StringBuilder提高效率原理图

![image-20231004235802610](assets/image-20231004235802610.png)

![image-20231004235841418](assets/image-20231004235841418.png)

所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存



扩展底层原理5：StringBuilder源码分析

- 默认创建一个长度为16的字节数组
- 添加的内容长度小于16，直接存
- 添加的内容大于16会扩容(原来的容量*2+2)
- 如果扩容之后还不够，以实际长度为准

扩容：

- 老容量*2+2
- 如果超出*2+2的容量则以实际容量为准

```java
StringBuilder sb = new StringBuilder();
sb.capcity();
sb.length();
```



# 10、ArrayList

## 10.1 集合的基本使用

集合和数组的对比

1. 长度可变
2. 添加数据的时候不需要考虑索引，默认将数据添加到末尾

ArrayList概述

- 什么是集合

    提供一种存储空间可变的存储模型，存储的数据容量可以发生改变

- ArrayList集合的特点

    **长度可以变化，只能存储引用数据类型。**

- 泛型的使用

    用于约束集合中存储元素的数据类型

|          | 数组                                         | 集合                                                     |
| -------- | -------------------------------------------- | -------------------------------------------------------- |
| 长度     | 固定                                         | 可变                                                     |
| 存储类型 | 可以存储基本数据类型<br />可以存引用数据类型 | 可以存引用数据类型<br />**基本数据类型需要转换为包装类** |

```java
ArrayList<String> list = new ArrayList<String>();
//JDK7
ArrayList<String> list = new ArrayList<>();
//此时我们创建的是ArrayList的对象，而ArrayList 是java已经写好的一个类
//这个类在底层做了一些处理
//打印对象不是地址值，而是集合中存储数据内容
//在展示的时候会拿[]把所有的数据进行包裹
```

## 10.2 ArrayList类常用方法

构造方法：

| 方法名             | 说明                 |
| ------------------ | -------------------- |
| public ArrayList() | 创建一个空的集合对象 |

成员方法：

| 方法名                      | 说明                                |
| --------------------------- | ----------------------------------- |
| public boolean add(E e)     | 添加元素，返回值表示是否添加成功    |
| public boolean remove(E e)  | 删除指定元素,返回值表示是否删除成功 |
| public E remove(int index)  | 删除指定索引的元素返回被删除元素    |
| public E set(int index,E e) | 修改指定索引下的元素,返回原来的元素 |
| public E get(int index)     | 获取指定索引的元素                  |
| public int size()           | 集合的长度，也就是集合中元素的个数  |



## 10.3 添加字符串和遍历

```java
public class Test1 {
    pub1ic static void main(string[] args) {
        //1.创建集合
        ArrayList<string> list = new ArrayList<>();

        //2.添加元衰
        list.add("点赞了吗? ");
        list.add("收藏了吗? ");
        list.add("投币了吗? ");
        list.add("转发了吗? ");

        //3.遍历
        System.out.print("[");
        for (1nt i = 0; i < list.size(); i++) {
            if(i == list.size() - 1){
                system.out.print(1ist .get(i));
            }e1se{
                System.out.print(1ist.get(i) + ",");
            }
        }
        system. out .println("]");
    }
}
```



## 10.4 添加基本数据类型

基本数据类型对应的包装类

| 基本数据类型 |  包装类   |
| :----------: | :-------: |
|     byte     |   Byte    |
|    short     |   Short   |
|     char     | Character |
|     int      |  Integer  |
|     long     |   Long    |
|    float     |   Float   |
|    double    |  Double   |
|   boolean    |  Boolean  |

```java
public class Test2 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<Integer> 1ist = new ArrayList<>();
        
        //2.添加元素
        //jdk5以后int Integer 之间是可以互相转化的
        1ist.add(1);
        1ist.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        
        //3.遍历集合
        System.out.print("[");
        for (1nt i = 0; i < list.size(); i++) {
            if(i == list.size() - 1){
                System.out.print(1ist.get(i));
            }e1se{
                System.out.print(1ist.get(i) + ",");
            }
        }
        system. out .println("]");
    }
}
```



# 11、面向对象进阶

## 11.1 static静态变量

static表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量

- 被static修饰的成员变量，叫做**静态变量**

    特点:

    - 被该类所有对象共享
    - 不属于对象，属于类。
    - **随着类的加载而加载，优先于对象存在**

    调用方式:

    - 类名调用 ( 推荐 )
    - 对象名调用.

- 被static修饰的成员方法，叫做**静态方法**

    特点:

    - 多用在测试类和**工具类**中
    - Javabean类中很少会用

    调用方式:

    - 类名调用(推荐)
    - 对象名调用

Java中成员（**变量和方法**）等是存在所属性的，Java是通过static关键字来区分的。**static关键字在Java开发非常的重要，对于理解面向对象非常关键。**

关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是**属于类**的是放在静态区中，没有static修饰的成员变量和方法则是**属于对象**的。

- static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。

- 无static修饰的成员，是属于对象，**对象有多少个，他们就会出现多少份**。所以必须由对象调用。

工具类

Javabean类：用来描述一类事物的类。 比如，Student, Teacher, Dog, Cat等

测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口

工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。

- **私有化构造方法：为了不让外界创建它的对象**
- **方法需要定义为静态，方便调用**



内存图：

![image-20231005145338776](assets/image-20231005145338776.png)



注意事项：

- 静态方法中，只能访问静态成员。
- 非静态方法可以访问所有。
- 静态方法中没有this关键字



## 11.2 继承

- Java中提供一个关键字 `extends`，用这个关键字，我们可以让一个类和另一个类建立起继承关系。

- ```java
    public class Student extends Person {}
    ```

- Student称为==子类（派生类）==，Person称为==父类（基类或超类）==。



使用继承的好处

- 可以把多个子类中重复的代码抽取到父类中了，提高代码的复用性。
- 子类可以在父类的基础上，增加其他的功能，使子类更强大。




什么时候用继承?

当类与类之间，存在相同(共性)的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码



继承后子类的特点?

- 子类可以得到父类的属性和行为，子类可以使用。
- 子类可以在父类的基础上新增其他功能，子类更强大。
- 子类可以直接访问父类中的**非私有**的属性和行为。





###  继承特点和体系设计

Java只支持单继承，不支持多继承，但支持多层继承。

单继承：一个子类只能继承一个父类

不支持多继承：子类不能同时继承多个父类

多层继承：子类A继承父类B，父类B可以继承父类C

子类A**直接继承**父类B，子类A**间接继承**父类C

==每一个类都直接或者间接的继承于Object==



总结：

1. ==Java只能单继承：一个类只能继承一个直接父类。==
2. Java不支持多继承、但是支持多层继承。
3. Java中所有的类都直接或者间接继承于0bject类。
4. 子类只能访问父类中非私有的成员



### 继承内存图

- **子类不能继承父类的构造方法。**
- **子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。**

![image-20231005151457130](assets/image-20231005151457130.png)

![image-20231005153118997](assets/image-20231005153118997.png)

只有父类中的虚方法才能被子类继承



### 继承中成员变量、方法和构造的访问特点

**成员变量**：就近原则：谁离我近，我就用谁

先在局部位置找，本类成员位置找，父类成员位置找，逐级往上。

```java
// 局部变量
name
// 成员变量
this.name
// 父类变量
super.name
```



**成员方法：**

直接调用满足就近原则：谁离我近，我就用谁

super调用，直接访问父类

作用：重写方法



**构造方法：**

- 父类中的构造方法不会被子类继承
- 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。

为什么?

- 子类在初始化的时候， 有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
- 子类初始化之前， 一定要调用父类构造方法先完成父类数据空间的初始化。

怎么调用父类构造方法的?

- **子类构造方法**的第一行语句默认都是：super()， 不写也存在，且必须在第一行。
- 如果想调用父类有参构造， 必须手动写super进行调用。

总结：

- 子类不能继承父类的构造方法，但是可以通过super调用
- 子类构造方法的第一行，有一个默认的super();
- 默认先访问父类中无参的构造方法，再执行自己。
- 如果想要方法文父类有参构造，必须手动书写。





### 重写方法

方法的重写

- 当父类的方法不能满足子类现在的需求时，需要进行方法重写

书写格式

- 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。

==@Override重写注解==

- @Override是放在重写后的方法上，校验子类重写时语法是否正确。
- 加上注解后如果有红色波浪线，表示语法错误。
- 建议重写方法都加@Override注解，代码安全，优雅!

![image-20231005154737858](assets/image-20231005154737858.png)

方法重写注意事项和要求

1. 重写方法的名称、形参列表必须与父类中的一致。

2. 子类重写父类方法时，**访问权限子类必须大于等于父类**(暂时了解 :空着不写< protected < public)

3. 子类重写父类方法时，**返回值类型子类必须小于等于父类**

4. 建议：重写的方法尽量和父类保持一致。 

5. 只有被添加到虚方法表中的方法才能被重写



方法重写的本质?

覆盖虛方法表中的方法



### this、super总结

this：理解为一个变量，表示当前方法调用者的地址值;
super：代表父类存储空间。

| 关键字 | 访问成员变量                         | 访问成员方法                             | 访问构造方法                    |
| ------ | ------------------------------------ | ---------------------------------------- | ------------------------------- |
| this   | this.成员变量<br />访问本类成员变量  | this.成员方法(...)<br />访问本类成员方法 | this(..)<br />访问本类构方法    |
| super  | super.成员变量<br />访问父类成员变量 | super.成员方(...)<br />访问父类成员方法  | super(..)<br />访问父类构造方法 |





## 11.3 多态

什么是多态?

- 同类型的对象，表现出的不同形态

多态的表现形式

- 父类类型 对象名称 = 子类对象;

**多态的前提**

- 有继承/实现关系

- 有父类引用指向子类对象

- 有方法重写



**多态中调用成员的特点**

- 变量调用：编译看左边，运行也看左边。
- 方法调用：编译看左边，运行看右边。

```java
Fu f = new Zi()；
//编译看左边的父类中有没有name这个属性，没有就报错
//在实际运行的时候，把父类name属性的值打印出来
System.out.println(f.name);
//编译看左边的父类中有没有show这个方法，没有就报错
//在实际运行的时候，运行的是子类中的show方法
f.show();
```



**多态的优势和弊端**

优势：

- 在多态形式下，右边对象可以实现解耦合,便于扩展和维护。

```java
Person p =new Student ();
p.work(); // 业务逻辑发生改变时，后续代码无需修改
```

- 
    定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

弊端：

- **不能调用子类的特有功能**

**解决方案：**

==引用类型转换==

### 引用类型转换

使用格式：

```java
Aniaml a = new Cat();
Cat c =(Cat) a;  
```

可能会出现如下转型的异常情况：

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat

        // 向下转型  
        Dog d = (Dog)a;       
        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】
    }  
}
```

这段代码可以通过编译，但是运行时，却报出了 `ClassCastException` ，类型转换异常！

这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。

### instanceof关键字

为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：

```java
变量名 instanceof 数据类型 
如果变量属于该数据类型或者其子类类型，返回true。
如果变量不属于该数据类型或者其子类类型，返回false。
```

所以，转换前，我们最好先做一个判断，代码如下：

```java
Animal a = new Dog();
Dog d = (Dog)a;
d.lookHome();

// 判断类型
if(a instanceof Dog){
    Dog d = (Dog)a;
	d.lookHome();
}else if(a instanceof Cat){
    Cat c = (Dog)a;
	c.lookHome();
}

// JDK14的时候提出了新特性，把判断和强转合并成了一行
if(a instanceof Dog d){
	d.lookHome();
}else if(a instanceof Cat c){
	c.lookHome();
}
```



- 当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。
- 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。
- 而且多态还可以根据传递的不同对象来调用不同类中的方法。



## 11.4 包

包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。

**包名的命名规范**：

```java
路径名.路径名.xxx.xxx
// 例如：com.itheima.oa
```

- 包名一般是公司域名的倒写。
- 包名必须用”.“连接。
- 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。

```java
package com.itheima.doain;

public class Student{
    
}
```

全类名/全限定名：包名+类名：com.itheima.domain.Student

### 导包

什么时候需要导包？

​	情况一：在使用Java中提供的非核心包中的类时

​	情况二：使用自己写的其他包中的类时

什么时候不需要导包？

​	情况一：在使用Java核心包（java.lang）中的类时

​	情况二：在使用自己写的同一个包中的类时

使用其他类的规则

​	使用其他类时，需要使用全类名。

```java
public class Test {
    public static void main(String[] args) {
        com.itheima.domain.Student s = new com.itheima.domain.Student();
    }
}
```

​	可以使用Import关键字，导包

```java
import com.itheima.domain.Student;

public class Test {
    public static void main(String[] args) {
        Student s = new Student();
    }
}
```

​	**如果同时使用两个包中的同类名，需要使用全类名**



## 11.5 final 关键字

Java提供了`final` 关键字，表示修饰的内容不可变。

- **final**：  不可改变，最终的含义。可以用于修饰类、方法和变量。
    - 类：被修饰的类，不能被**继承**。
    - 方法：被修饰的方法，不能被**重写**。
    - 变量：被修饰的变量，有且仅能被**赋值一次**。



修饰类：final修饰的类，不能被继承

```java
final class Fu {
}
// class Zi extends Fu {} // 报错,不能继承final的类
```

查询API发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。



修饰方法：final修饰的方法，不能被重写。

```java
class Fu2 {
	final public void show1() {
		System.out.println("Fu2 show1");
	}
	public void show2() {
		System.out.println("Fu2 show2");
	}
}

class Zi2 extends Fu2 {
//	@Override
//	public void show1() {
//		System.out.println("Zi2 show1");
//	}
	@Override
	public void show2() {
		System.out.println("Zi2 show2");
	}
}
```



==**修饰变量**：==

局部变量：基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。

成员变量：

成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：

- **显示初始化**(在定义成员变量的时候立马赋值)（常用）；

```java
public class Student {
    final int num = 10;
}
```

- **构造方法初始化**(在构造方法中赋值一次)（不常用，了解即可）。

    **注意：每个构造方法中都要赋值一次！**

```java
public class Student {
    final int num = 10;
    final int num2;

    public Student() {
        this.num2 = 20;
//     this.num2 = 20;
    }
    
     public Student(String name) {
        this.num2 = 20;
//     this.num2 = 20;
    }
}
```

> 被final修饰的常量名称，一般都有书写规范，所有字母都**大写**。



### 常量

实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。

命名规范：

- 单个单词：全部大写
- 多个单词：全部大写，**单词之间用下划线隔开**

细节：

- final 修饰的变量时基本类型：那么变量存储的==数据值==不能发生改变。
- final 修饰的变量时引用类型：那么变量存储的==地址值==不能发生改变，对象内部可以改变。



## 11.6 权限修饰符

- 权限修饰符：是用来控制一个成员能够被访问的范围的。
- 可以修饰成员变量，方法，构造方法，内部类。

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。

- `public`：公共的，所有地方都可以访问。

- `protected`：本类 ，本包，其他包中的子类都可以访问。

- `默认（没有修饰符）`：本类 ，本包可以访问。

    注意：默认是空着不写，不是default

- `private`：私有的，当前类可以访问。

`public > protected > 默认 > private`

| 修饰符    | 同一类中 | 同一包中的类 | 不同包的子类 | 不同包中的无关类 |
| --------- | -------- | ------------ | ------------ | ---------------- |
| private   | √        |              |              |                  |
| 默认      | √        | √            |              |                  |
| protected | √        | √            | √            |                  |
| public    | √        | √            | √            | √                |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用`private` ，隐藏细节。
- 构造方法使用` public` ，方便创建对象。
- 成员方法使用`public` ，方便调用方法。

> 小贴士：不加权限修饰符，就是默认权限



## 11.7 代码块

- 局部代码块
- 构造代码块



### 局部代码块

**作用：提前结束变量的声明周期**

```java
public class Test{
    public static void main(String[] args){
        {
            int a = 10;
            System.out.println(a);
        }
    }
}
```

### 构造代码块

**作用：将构造函数重复的代码写在构造代码块中，它会优先于构造方法执行。**

```java
public class Student{
    private String name;
    private int age;
    {
        System.out.println("开始创建对象");
    }
    public Student(){}
    public Student(String name, int age){
        this.name = name;
        this.age = age;
    }
}
```

这种写法逐渐被淘汰，因为所有的构造函数都会执行代码块。

处理方法：

```java
public class Student{
    private String name;
    
    public Student(){
        this(null, 0);
    }
    public Student(String name, int age){
        System.out.println("开始创建对象");
        this.name = name;
        this.age = age;
    }
}
```

或者

```java
public class Student{
    private String name;
    
    public Student(){
        调用方法();
    }
    public Student(String name, int age){
        调用方法();
        this.name = name;
        this.age = age;
    }
}
```



### 静态代码块

格式：static

特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次

**使用场景：在类加载的时候，做一些数据初始化的时候使用。**



## 11.8 抽象类和抽象方法

### 抽象类引入

**我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类**。

- **抽象方法**： 没有方法体的方法。
- **抽象类**：包含抽象方法的类。

### abstract使用格式

**abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。**

抽象方法：

使用`abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

定义格式：

```java
修饰符 abstract 返回值类型 方法名 (参数列表);
```

代码举例：

```java
public abstract void run();
```

抽象类：

如果一个类包含抽象方法，那么该类必须是抽象类。

**注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。**

定义格式：

```java
abstract class 类名字 { 
}
```

代码举例：

```java
public abstract class Animal {
    public abstract void run()；
}
```

### 抽象类的细节

1. 抽象类不能创建对象
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则子类也必须定义成抽象类。 
5. 抽象类存在的意义是为了被子类继承。

抽象类的作用：

抽取共性时，无法确定方法体，就把方法定义为抽象的。

强制让子类按照某种格式重写。

抽象方法所在的类，必须是抽象类。



## 11.9 接口

什么是接口呢？

**接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的**。

<img src="assets/image-20231107164223089.png" alt="image-20231107164223089" style="zoom: 33%;" />

接口不代表一类事物，**接口就是一个规则，是行为的一种抽象。**

在JDK7，包括JDK7之前，接口中的**只有**包含：抽象方法和常量

抽象方法：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！

变量： public static final 修饰

定义格式：

```java
//接口的定义格式：
interface 接口名称{
    // 抽象方法
}

// 接口的声明：interface
// 接口名称：首字母大写，满足“驼峰模式”
```

- 接口不能实例化
- 接口与类之间是实现关系，通过implements关键字表示

接口的实现：

```java
/**接口的实现：
    在Java中接口是被实现的，实现接口的类称为实现类。
    实现类的格式:*/
class 类名 implements 接口1,接口2,接口3...{
}
```

接口的子类

- 要么重写接口中的所有抽象方法
- 要么是抽象类
- 接口和类之间是实现关系，可以单实现，也可以多实现
- 实现类可以在继承一个类的同时实现多个接口

**意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。**



### 成员特点

- 成员变量
    - 只能是常量
    - 默认修饰符：public static final
- 构造方法
    - 没有
- 成员方法
    - 只能是抽象方法
    - 默认修饰符：public abstract
- JDK7以前：接口中只能定义抽象方法。
- JDK8的新特性：接口中可以定义有方法体的方法。
- JDK9的新特性：接口中可以定义私有方法。

内存测试工具：`jhsdb hsdb`



### 接口和类之间的关系

- 类和类的关系
    - 继承关系，只能单继承，不能多继承，但是可以多层继承
- 类和接口的关系
    - 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
    - 当类实现多个接口时，如果接口中有同名的方法，我们只要重写一次即可。
- 接口和接口的关系
    - 继承关系，可以单继承，也可以多继承
    - 如果类实现了最下面的子接口，那么需要重写所有抽象方法



### 接口拓展

JDK8开始接口中新增的方法

- JDK7以前：接口中只能定义抽象方法。
- JDK8的新特性：接口中可以定义有方法体的方法。(默认、 静态)
- JDK9的新特性：接口中可以定义私有方法。

为什么需要新增方法？

在JDK7以前，接口添加新的方法，所有实现该接口的类都需要修改，否则会报错。

解决方案：在接口里添加有方法体的方法。



**JDK8以后接口中新增的方法**

- 允许在接口中定义默认方法，需要使用关键字default修饰
    - **作用:解决接口升级的问题**

- 接口中默认方法的定义格式:
    - 格式: `public default 返回值类型 方法名(参数列表){ }`
    - 范例: `public default void show(){ }`

- 接口中默认方法的注意事项:
    - 默认方法不是抽象方法， 所以不强制被重写。但是如果被重写，重写的时候去掉default关键字
        public可以省略，default不能省略
    - **如果实现了多个接口， 多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写**

- 接口中静态方法的定义格式：
    - 格式: `public static 返回值类型 方法名(参数列表){ }`
    - 范例: `public static void show(){ }`
- 接口中静态方法的注意事项:
    - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
    - public可以省略，static不能省略。



**JDK9新增的方法**

- 接口中私有方法的定义格式:

    - 格式1: private 返回值类型方法名(参数列表){ }

        范例1: `private void show() { }`

    - 格式2: private static返回值类型方法名(参数列表){ }

        范例2: `private static void method(){ }`

总结：

1. JDK7以前：接口中只能定义抽象方法。
2. JDK8：接口中可以定义有方法体的方法。(默认、 静态)
3. JDK9：接口中可以定义私有方法。
4. 私有方法分为两种：普通的私有方法，静态的私有方法



### 接口的应用

1. 接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。
2. 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为==接口多态==。



### 适配器设计模式

- 设计模式(Design pattern)是一套被反复使用、 多数人知晓的、经过分类编目的、代码设计经验的总结。

    使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

- 适配器设计模式：解决接口与接口实现类之间的矛盾问题。



适配器设计模式：当一个接口中抽象方法过多，但是我只有使用其中一部分的时候，就可以使用适配器设计模式。

步骤：

1. 编写中间类：XXXAdapter，实现对应的接口

    对接口中抽象方法进行空实现

2. 让真正的实现类继承中间类，并重写需要用的方法

3. 为了避免其他类创建适配器的对象，中间的适配器类用abstract进行修饰



## 11.10 内部类

类的五大成员：

属性、方法、构造方法、代码块、内部类



**什么是内部类？**

在一个类的里面，再定义一个类。

- 内部类表示的事物是外部类的一部分
- 内部类单独出现没有任何意义



**内部类的访问特点**

- **内部类可以直接访问外部类的成员，包括私有**
- **外部类要访问内部类的成员，必须创建对象**



**什么时候用到内部类？**

B类表示的事物是A类的一部分，且B单独存在没有意义。

比如: 汽车的发动机，ArrayList的迭代器，人的心脏等等



内部类分类：

- 成员内部类
- 静态内部类
- 局部静态类
- 匿名内部类



### 成员内部类

- 写在成员位置的，属于外部类的成员
- 类内，方法外



**成员内部类的代码如何书写**

```java
public class Car{
    String carName;
    int carAge;
    int carColor;
    class Engine{
        String engineName;
        int engineAge;
    }
}
```

- 成员内部类可以被一些修饰符所修饰，比如：private，默认，protected，public，static等。

- 成员内部类里，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。



**获取成员内部类对象**

方式一：在外部类中编写方法，对外提供内部类的对象（private）

```java
public class Outer{
    
    private class Inner{
        
    }
    
    public Inner getInstance(){
        return new Inner();
    }
}
```

方法二：直接创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象

```java
Outer.Inner oi = new Outer().new Inner();

Outer o = new Outer();
//Outer.Inner oi = o.getInstance();	//报错，因为Inner在外部不可见，不可知Outer.Inner类型
object oi = o.getInstance();
```

成员内部类用private修饰，则不能在外部创建对象。

可以通过提供方法，对外提供内部类对象。



外部类成员变量和内部类成员变量重名时，在内部类如何访问。

```java
public class Outer{
    private int a = 10;
    
    class Inner{
        private int a = 20;
        
        public void show(){
            int a = 30;
            System.out.println(a);	//30
            System.out.println(this.a);	//20
            System.out.println(Outer.this.a);	//10
        }
    }
}
```



**内部类的内存图**

![image-20231107201722439](assets/image-20231107201722439.png)

内部类有一个隐藏的 this，记录了外部类的地址值。



### 静态内部类

静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。

创建静态内部类对象的格式：`外部类名.内部类名 对象名 = new 外部类名.内部类名(); `

- 调用非静态方法的格式：先创建对象，用对象调用

- 调用静态方法的格式：外部类名.内部类名.方法名();

```java
public class Outer{
    int a = 10;
    static int b = 20;
    
    static class Inner{
        public void show1(){
            Outer o = new Outer();
            System.out.println(O.a);
            System.out.println(b);
        }
        public static void show2(){
            Outer o = new Outer();
            System.out.println(O.a);
            System.out.println(b);
        }
    }
}
```

创建静态内部类对象：

```java
//用类名创建对象
Outer.Inner oi = new Outer.Inner();
oi.show1();
oi.show2();
Outer.Inner.show2();
```



### 局部内部类

1. 将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。
2. 外界是无法直接使用，需要在方法内部创建对象并使用。
3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

```java
public class Outer{
    int b = 20;
    public void show(){
        int a = 10;
        
        class Inner{
       		public void method1(){
                sout(a);	//访问方法内的局部变量
                sout(b);	//访问外部类的成员
            }
    	}
        //在方法内部创建对象
        Inner i = new Inner();
    }
}
```



### 匿名内部类

匿名内部类本质上就是隐藏了名字的内部类。

格式：

```java
new 类名或者接口名(){
  	重写方法;  
};
```

匿名内部类实现过程：

1. 继承关系/实现关系
2. 方法重写
3. 创建对象

```java
new Swim(){
    @Override
    public void swim(){
        sout("");
    }
};
```

总结：

1. 什么是匿名内部类？

    隐藏了名字的内部类，==可以写在成员位置，也可以写在局部位置==。

2. 匿名内部类格式的细节

    包含了继承或实现，方法重写，创建对象。

    整体就是一个类的子类对象或者接口的实现类对象。

3. 使用场景
    当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象， 如果实现类只要使用一次，就可以用匿名内部类简化代码。



































